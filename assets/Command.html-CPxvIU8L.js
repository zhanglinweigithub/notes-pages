import{_ as t,o as e,c as n,a}from"./app-Vg0IViah.js";const s="/notes-pages/assets/image-20240210232024506-DOYt2m_n.png",l="/notes-pages/assets/image-20240211130041906-CfrwdH_h.png",i={},p=a('<h1 id="指令系统" tabindex="-1"><a class="header-anchor" href="#指令系统"><span>指令系统</span></a></h1><h2 id="一、指令组成" tabindex="-1"><a class="header-anchor" href="#一、指令组成"><span>一、指令组成</span></a></h2><p><strong>计算机指令的组成：</strong> 一条指令由 <strong>操作码</strong> 和 <strong>操作数</strong> 两部分组成， 操作码决定要完成的操作， 操作数指参加运算的数据及其所在的单元地址。</p><p>操作要求和操作数地址都由 <strong>二进制数码</strong> 表示，分别称作 <strong>操作码</strong> 和 <strong>地址码</strong> ，整条指令以二进制编码的形式存放在存储器中</p><h2 id="二、执行过程" tabindex="-1"><a class="header-anchor" href="#二、执行过程"><span>二、执行过程</span></a></h2><p><strong>计算机指令执行过程：</strong> 取指令——分析指令——执行指令三个步骤</p><ol><li>首先将 程序计数器PC中的指令地址取出，送入地址总线， CPU依据指令地址去内存 中 取出指令内容存入指令寄存器IR；</li><li>而后由指令译码器进行分析， 分析指令操作码；</li><li>最后执行指令， 取出指令执行所需的源操作数 。</li></ol><h2 id="三、寻址方式" tabindex="-1"><a class="header-anchor" href="#三、寻址方式"><span>三、寻址方式</span></a></h2><h3 id="_1、指令寻址方式" tabindex="-1"><a class="header-anchor" href="#_1、指令寻址方式"><span>1、指令寻址方式</span></a></h3><p>指令寻址方式（怎么找到下一条指令）</p><ul><li><strong>顺序寻址方式：</strong> 当执行一段程序时，根据PC（程序计数器） 中指令，是一条指令接着一条指令地顺序执行。</li><li><strong>跳跃寻址方式：</strong> 指下一条指令的地址码不是由程序计数器给出， 而是由本条指令直接给出。 程序跳跃后，按新的指令地址开始顺序执行。因此，程序计数器的内容也必须相应改变， 以便及时跟踪新的指令地址。</li></ul><h3 id="_2、指令操作数寻址方式" tabindex="-1"><a class="header-anchor" href="#_2、指令操作数寻址方式"><span>2、指令操作数寻址方式</span></a></h3><p>指令操作数的寻址方式（怎么找到操作数）</p><ul><li><p><strong>立即寻址方式：</strong> 指令的地址码字段指出的不是地址， 而是操作数本身。</p></li><li><p><strong>直接寻址方式：</strong> 在指令的地址字段中直接指出操作数在主存中的地址。</p></li><li><p><strong>间接寻址方式：</strong> 指令地址码字段所指向的存储单元中存储的是操作数的地址。</p></li><li><p><strong>寄存器寻址方式：</strong> 指令中的地址码是寄存器的编号。</p></li><li><p><strong>基址寻址方式：</strong> 将基址寄存器的内容加上指令中的形式地址而形成操作数的有效地址，其优点是可以扩大寻址能力。</p></li><li><p><strong>变址寻址方式：</strong> 变址寻址方式计算有效地址的方法与基址寻址方式很相似， 它是将变址寄存器的内容加上指令中的形式地址而形成操作数的有效地址。</p></li></ul><h2 id="四、指令系统类型" tabindex="-1"><a class="header-anchor" href="#四、指令系统类型"><span>四、指令系统类型</span></a></h2><ul><li>CISC是复杂指令系统，兼容性强， 指令繁多、长度可变， 由微程序实现；</li><li>RISC是精简指令系统，指令少，使用频率接近， 主要依靠硬件实现（通用寄存器、硬布线 逻辑控制）。</li></ul><p><strong>区别如下：</strong></p><table><thead><tr><th>指令系统类型</th><th>指令</th><th>寻址方式</th><th>实现方式</th><th>其它</th></tr></thead><tbody><tr><td>CISC（复杂）</td><td>数量多，使用频率差别大，可变长格式</td><td>支持多种</td><td>微程序控制技术（微码）</td><td>研制周期长</td></tr><tr><td>RISC（精简）</td><td>数量少，使用频率接近，定长格式，大部分为单周期指令，操作寄存器，只有Load/Store操作内存</td><td>支持方式少</td><td>增加了通用寄存器：硬布线逻辑控制为主，适合采用流水线</td><td>优化编译，有效支持高级语言</td></tr></tbody></table><h2 id="五、指令流水线" tabindex="-1"><a class="header-anchor" href="#五、指令流水线"><span>五、指令流水线</span></a></h2><h3 id="_1、指令流水线原理" tabindex="-1"><a class="header-anchor" href="#_1、指令流水线原理"><span>1、指令流水线原理</span></a></h3><p><strong>指令流水线原理：</strong> 将指令分成不同段，每段由不同的部分去处理， 因此可以产生叠加的效果， 所有的部件去处理指令的不同段。</p><p>取指 ===&gt; 分析 ===&gt; 执行 ===&gt;</p><figure><img src="'+s+'" alt="image-20240210232112882" tabindex="0" loading="lazy"><figcaption>image-20240210232112882</figcaption></figure><p><strong>RISC中的流水线技术：</strong></p><ol><li>超流水线（ Super Pipe Line）技术 。 它通过细化流水、增加级数和提高主频，使得在每个机器周期内能完成一个甚至两个浮点操作。其实质是以时间换取空间。</li><li>超标量（ Super Scalar）技术。它通过内装多条流水线来同时执行多个处理， 其时钟频率虽然与一般流水接近， 却有更小的 CPI 。其实质是以空间换取时间。</li><li>超长指令字（ Very Long Instruction Word ，VLIW ）技 术 。 VLIW和超标量都是 20世纪80年代出现的概念， 其共同点是要同时执行多条指令， 其不同在于超标量依靠硬件来实现并行处理的调度，VLIW则充分发挥软件的作用， 而使硬件简化，性能提高。</li></ol><h3 id="_2、指令流水线计算" tabindex="-1"><a class="header-anchor" href="#_2、指令流水线计算"><span>2、指令流水线计算</span></a></h3><p>流水线时间计算：</p><ol><li>流水线周期： 指令分成不同执行段， 其中执行时间最长的段为流水线周期。</li><li>流水线执行时间： 1条指令总执行时间＋（总指令条数-1 ）＊流水线周期。</li><li>流水线吞吐率计算： 吞吐率即单位时间内执行的指令条数。 公式： 指令条数／流水线执行时间。</li><li>流水线的加速比计算：加速比即使用流水线后的效率提升度， 即比不使用流水线快了多少倍， 越高表明流水线效率越高， 公式： 不使用流水线执行时间／使用流水线执行时间。</li></ol><h2 id="五、练习" tabindex="-1"><a class="header-anchor" href="#五、练习"><span>五、练习</span></a></h2><p>1、Flynn分类法根据计算机在执行程序的过程中（） 的不同组合， 将计算机分为4类 。当前主流的多核计算机属于（） 计算机。</p><p>A：指令流和数据流</p><p>B：数据流和控制流</p><p>C：指令流和控制流</p><p>D：数据流和总线带宽</p><details class="hint-container details"><summary>答案</summary><p>AD</p><figure><img src="'+l+'" alt="image-20240211130041906" tabindex="0" loading="lazy"><figcaption>image-20240211130041906</figcaption></figure></details><p>2、以下关于复杂指令集计算机（Complex Instruction Set Computer， CISC） 的叙述中， 正确的是（） 。</p><p>A：只设置使用频度高的一些简单指令， 不同指令执行时间差别很小</p><p>B：CPU中设置大量寄存器， 利用率低</p><p>C：常采用执行速度更快的组合逻辑实现控制器</p><p>D：指令长度不固定， 指令格式和寻址方式多变</p><details class="hint-container details"><summary>答案</summary><p>D</p></details><p>3、流水线的吞吐率是指流水线在单位时间里所完成的任务数或输出的结果数 。设某流水线有5段， 有1段的时间为2ns， 另外4段的每段时间为1ns， 利用此流水线完成100个任务的吞吐率约为（） 个／s 。</p><p>A：500x10^6</p><p>B：490x10^6</p><p>C：250x10^6</p><p>D：167x10^6</p><details class="hint-container details"><summary>答案</summary><p>B</p><p>流水线执行100个任务需要时间：（ 2+1+1+1+1） +（ 100- 1 ）<code>*</code> 2 = 204ns</p><p>吞吐率：（ 100/204 ）<code>*</code> 10^9 = 490<code>*</code>10^6</p><p>1s = 10^9ns</p></details><p>4、假设磁盘块与缓冲区大小相同， 每个盘块读入缓冲区的时间为15us， 由缓冲区送至用户区的时间是5us， 在 用户区内系统对每块数据的处理时间为1us， 若用户需要将大小为10个磁盘块的Docl文件逐块从磁盘读入缓冲区， 并送至用户区进行处理， 那么采用单缓冲区需要花费的时间为（） us； 采用双缓冲区需要花费的时间 为（） us。</p><p>A：150</p><p>B：151</p><p>C：156</p><p>D：201</p><details class="hint-container details"><summary>答案</summary><p>DC</p><p>单缓冲区： 前两段合并， 两端流水线， 20+1 + （ 10-1 ）* 20 =201</p><p>双缓冲区： 标准三段流水线， 15+5+1 + （ 10- 1 ）* 15= 156</p></details><p>5、流水线技术是通过并行硬件来提高系统性能的常用方法 。对于一个k段流水线， 假设其各段的执行时间均相等（设为t），输入到流水线中的任务是连续的理想情况下， 完成n个连续任务需要的总时间为（） 。若某流水线浮点加法运算器分为5段， 所需要的时间分别是6ns 、7ns 、8ns 、9ns和6ns， 则其最大加速比为（）</p><p>A：nkt A：4</p><p>B：(k+n- 1)t B：5</p><p>C：(n-k)kt C：6</p><p>D：(k+n+1)t D：7</p><details class="hint-container details"><summary>答案</summary><p>BA</p><p>当流水线各段执行时间相等时， 公式化简后， 完成n个连续任务需要的总时间爱你为<code>(k+n- 1)*t</code> 。</p><p>加速比定义为顺序执行时间与流水线执行时间的比值 ，根据题干假设， 假设一共有n条指令， 则顺序执行时间为 <code>(6+7+8+9+6) * n = 36n</code>， 该流水线周期为最长的9ns， 则在流水线中执行的时间为<code>36+9*（ n- 1 ）=9n+27</code> ， 因此加速比为<code>36n/（ 9n+27）</code>，题目问最大加速比， 由这个公式可以知道， 当n越大时， 该公式值越大， 因此最大的时间就是n趋向于无穷大， 此时可以忽略分母27， 也就是<code>36n /9n=4</code> 。</p></details>',59),r=[p];function o(d,c){return e(),n("div",null,r)}const g=t(i,[["render",o],["__file","Command.html.vue"]]),m=JSON.parse('{"path":"/SoftTest/Conventional/Command.html","title":"指令系统","lang":"zh-CN","frontmatter":{"order":3,"category":"软考","feed":false,"seo":false},"headers":[{"level":2,"title":"一、指令组成","slug":"一、指令组成","link":"#一、指令组成","children":[]},{"level":2,"title":"二、执行过程","slug":"二、执行过程","link":"#二、执行过程","children":[]},{"level":2,"title":"三、寻址方式","slug":"三、寻址方式","link":"#三、寻址方式","children":[{"level":3,"title":"1、指令寻址方式","slug":"_1、指令寻址方式","link":"#_1、指令寻址方式","children":[]},{"level":3,"title":"2、指令操作数寻址方式","slug":"_2、指令操作数寻址方式","link":"#_2、指令操作数寻址方式","children":[]}]},{"level":2,"title":"四、指令系统类型","slug":"四、指令系统类型","link":"#四、指令系统类型","children":[]},{"level":2,"title":"五、指令流水线","slug":"五、指令流水线","link":"#五、指令流水线","children":[{"level":3,"title":"1、指令流水线原理","slug":"_1、指令流水线原理","link":"#_1、指令流水线原理","children":[]},{"level":3,"title":"2、指令流水线计算","slug":"_2、指令流水线计算","link":"#_2、指令流水线计算","children":[]}]},{"level":2,"title":"五、练习","slug":"五、练习","link":"#五、练习","children":[]}],"git":{"createdTime":1710676914000,"updatedTime":1710676914000,"contributors":[{"name":"zhanglinwei","email":"3498729975@qq.com","commits":1}]},"readingTime":{"minutes":7.23,"words":2169},"filePathRelative":"SoftTest/Conventional/Command.md","localizedDate":"2024年3月17日"}');export{g as comp,m as data};
