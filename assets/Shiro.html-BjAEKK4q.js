import{_ as d,r as i,o as t,c as r,e,f as o,g as a,a as n}from"./app-Vg0IViah.js";const s="/notes-pages/assets/image-20230913114129266-DJENe6Gv.png",l="/notes-pages/assets/image-20230913152140961-DOZCzHmf.png",g="/notes-pages/assets/image-20230913152622660-CKIkbNRw.png",h={},p=e("h1",{id:"shiro",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#shiro"},[e("span",null,"Shiro")])],-1),S=e("p",null,[e("code",null,"Shiro"),o(" 是一个功能强大且易于使用的 "),e("code",null,"Java"),o(" 安全(权限)框架。")],-1),u=e("p",null,[e("code",null,"Shiro"),o(" 可以完 成：认证、授权、加密、会话管理、与 "),e("code",null,"Web"),o(" 集成、缓存等。")],-1),m={href:"https://shiro.apache.org/",target:"_blank",rel:"noopener noreferrer"},_=n('<p><strong>功能如图：</strong></p><figure><img src="'+s+'" alt="image-20230913151644069" tabindex="0" loading="lazy"><figcaption>image-20230913151644069</figcaption></figure><p><strong>常用功能：</strong></p><ul><li><code>Authentication</code>：身份认证/登录</li><li><code>Authorization</code>：授权；即权限验证，验证某个已认证的用户是否拥有某个权限</li><li><code>Session Manager</code>：会话管理；即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中</li><li><code>Cryptography</code>：加密</li><li><code>Remember Me</code>：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了</li></ul><p><strong>其它：</strong></p><ul><li><code>Web Support</code>：<code>Web</code> 支持，可以非常容易的集成到 <code>Web</code> 环境</li><li><code>Caching</code>：缓存，比如用户登录后，其用户信息、拥有的角色 / 权限不必每次去查，这样可以提高效率</li><li><code>Concurrency</code>：<code>shiro</code> 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去</li><li><code>Testing</code>：提供测试支持</li><li><code>Run As</code>：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问</li></ul><div class="hint-container tip"><p class="hint-container-title">提示</p><p>记住一点，<code>Shiro</code> 不会去维护用户、维护权限；</p><p>这些需要我们自己去设计 / 提供；</p><p>然后通过相应的接口注入给 <code>Shiro</code> 即可。</p></div><h2 id="外部架构" tabindex="-1"><a class="header-anchor" href="#外部架构"><span>外部架构</span></a></h2><p>首先，我们从外部来看 <code>Shiro</code> ，即从应用程序角度的来观察如何使用 <code>Shiro</code> 完成工作。如下图：</p><figure><img src="'+l+'" alt="image-20230913152140961" tabindex="0" loading="lazy"><figcaption>image-20230913152140961</figcaption></figure><p>可以看到：应用代码直接交互的对象是 <code>Subject</code>，也就是说 <code>Shiro</code> 的对外 <code>API</code> 核心就是 <code>Subject</code>；</p><p><strong>Subject：</strong> 主体，代表了当前 “用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是<code>Subject</code>即一个抽象概念；</p><p>所有 <code>Subject</code> 都绑定到 <code>SecurityManager</code>，与 <code>Subject</code> 的所有交互都会委托给 <code>SecurityManager</code>；可以把 <code>Subject</code> 认为是一个门面；<code>SecurityManager</code> 才是实际的执行者；</p><p><strong>SecurityManager：</strong> 安全管理器；即所有与安全有关的操作都会与 <code>SecurityManager</code> 交互；且它管理着所有 <code>Subject</code>；它是 <code>Shiro</code> 的核心，它负责与后边介绍的其他组件进行交互</p><p><strong>Realm：</strong> 域，<code>Shiro</code> 从 <code>Realm</code> 获取安全数据（如用户、角色、权限），就是说 <code>SecurityManager</code> 要验证用户身份，那么它需要从 <code>Realm</code> 获取相应的用户进行比较以确定用户身份是否合法；也需要从 <code>Realm</code> 得到用户相应的角色 / 权限进行验证用户是否能进行操作；</p><p>最简单的一个 <code>Shiro</code> 应用：</p><ol><li>应用代码通过 <code>Subject</code> 来进行认证和授权，而 <code>Subject</code> 又委托给 <code>SecurityManager</code>；</li><li>我们需要给 <code>Shiro</code> 的 <code>SecurityManager</code> 注入 <code>Realm</code>，从而让 <code>SecurityManager</code> 能得到合法的用户及其权限进行判断。</li></ol><h2 id="内部架构" tabindex="-1"><a class="header-anchor" href="#内部架构"><span>内部架构</span></a></h2><p>接下来我们来从 <code>Shiro</code> 内部来看下 <code>Shiro</code> 的架构，如下图所示：</p><figure><img src="'+g+'" alt="image-20230913152622660" tabindex="0" loading="lazy"><figcaption>image-20230913152622660</figcaption></figure><ul><li><strong>Subject：</strong> 主体，可以看到主体可以是任何可以与应用交互的 “用户”；</li><li><strong>SecurityManager：</strong> 相当于 <code>SpringMVC</code> 中的 <code>DispatcherServlet</code> ；是 <code>Shiro</code> 的心脏；所有具体的交互都通过 <code>SecurityManager</code> 进行控制；它管理着所有 <code>Subject</code>、且负责进行认证和授权、及会话、缓存的管理。</li><li><strong>Authenticator：</strong> 认证器，负责主体认证的，这是一个扩展点，如果用户觉得 <code>Shiro</code> 默认的不好，可以自定义实现；其需要认证策略（Authentication Strategy），即什么情况下算用户认证通过了；</li><li><strong>Authorizer：</strong> 授权器，或者访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能；</li><li><strong>Realm：</strong> 可以有 1 个或多个 <code>Realm</code>，可以认为是安全实体数据源，即用于获取安全实体的；由用户提供；注意：<code>Shiro</code> 不知道你的用户 / 权限存储在哪及以何种格式存储；所以我们一般在应用中都需要实现自己的 <code>Realm</code>；</li><li><strong>SessionManager：</strong> 如果写过 <code>Servlet</code> 就应该知道 <code>Session</code> 的概念，<code>Session</code> 呢需要有人去管理它的生命周期，这个组件就是 <code>SessionManager</code>；而 <code>Shiro</code> 并不仅仅可以用在 <code>Web</code> 环境，也可以用在如普通的 <code>JavaSE</code> 环境等；所以呢，<code>Shiro</code> 就抽象了一个自己的 <code>Session</code> 来管理主体与应用之间交互的数据；这样的话，比如我们在 <code>Web</code> 环境用，刚开始是一台 <code>Web</code> 服务器；接着又上了台 <code>EJB</code> 服务器；这时想把两台服务器的会话数据放到一个地方，这个时候就可以实现自己的分布式会话（如把数据放到 <code>Memcached</code> 服务器）；</li><li><strong>SessionDAO：</strong> <code>DAO</code> 大家都用过，数据访问对象，用于会话的 <code>CRUD</code>，比如我们想把 <code>Session</code> 保存到数据库，那么可以实现自己的 <code>SessionDAO</code>，通过如 <code>JDBC</code> 写到数据库；比如想把 <code>Session</code> 放到 <code>Memcached</code> 中，可以实现自己的 <code>Memcached SessionDAO</code>；另外 <code>SessionDAO</code> 中可以使用 <code>Cache</code> 进行缓存，以提高性能；</li><li><strong>CacheManager：</strong> 缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能</li><li><strong>Cryptography：</strong> 密码模块，<code>Shiro</code> 提供了一些常见的加密组件用于如密码加密 / 解密的。</li></ul>',21);function b(f,y){const c=i("ExternalLinkIcon");return t(),r("div",null,[p,S,u,e("p",null,[o("官网："),e("a",m,[o("https://shiro.apache.org/"),a(c)])]),_])}const v=d(h,[["render",b],["__file","Shiro.html.vue"]]),C=JSON.parse('{"path":"/Use/Java/Shiro/Shiro.html","title":"Shiro","lang":"zh-CN","frontmatter":{"order":1,"category":"使用篇"},"headers":[{"level":2,"title":"外部架构","slug":"外部架构","link":"#外部架构","children":[]},{"level":2,"title":"内部架构","slug":"内部架构","link":"#内部架构","children":[]}],"git":{"createdTime":1708330205000,"updatedTime":1708873062000,"contributors":[{"name":"zhanglinwei","email":"3498729975@qq.com","commits":2}]},"readingTime":{"minutes":4.5,"words":1349},"filePathRelative":"Use/Java/Shiro/Shiro.md","localizedDate":"2024年2月19日"}');export{v as comp,C as data};
