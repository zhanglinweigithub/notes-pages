import{_ as t,o as a,c as e,a as d}from"./app-Vg0IViah.js";const i="/notes-pages/assets/image-20240211134902452-RJ_Ss9Xe.png",h="/notes-pages/assets/image-20240211133239973-CCAwCS1H.png",s="/notes-pages/assets/image-20240211135549076-DLLR5jIX.png",p="/notes-pages/assets/image-20240211135930913-Bh9xRh_g.png",n="/notes-pages/assets/image-20240211133908453-gSKk4OiN.png",l={},r=d('<h1 id="存储系统和缓存" tabindex="-1"><a class="header-anchor" href="#存储系统和缓存"><span>存储系统和缓存</span></a></h1><h2 id="一、分级存储体系" tabindex="-1"><a class="header-anchor" href="#一、分级存储体系"><span>一、分级存储体系</span></a></h2><figure><img src="'+i+'" alt="image-20240211134902452" tabindex="0" loading="lazy"><figcaption>image-20240211134902452</figcaption></figure><p>由上到下：速度越来越慢、容量越来越大、成本越来越低</p><blockquote><p>主存储器：内存</p></blockquote><p>计算机采用分级存储体系的主要 <strong>目的是为了解决存储容量、成本和速度之间的矛盾</strong> 问题。</p><p>两级存储： Cache -主存 、主存 -辅存（虚拟存储体系） 。</p><p>局部性原理 ： 总的来说， 在CPU运行时， 所访问的数据会趋向于一个较小的局部空间地址内， 包括下面两个方面：</p><ul><li>时间局部性原理： 如果一个数据项正在被访问，那么在近期它很可能会被再次访问， 即在相邻的时间里会访问同一个数据项。</li><li>空间局部性原理： 在最近的将来会用到的数据的地址和现在正在访问的数据地址很可能是相近的， 即相邻的空间地址会被连续访问。</li></ul><h2 id="二、缓存" tabindex="-1"><a class="header-anchor" href="#二、缓存"><span>二、缓存</span></a></h2><p>高速缓存Cache用来存储当前最活跃的程序和数据， 直接与CPU交互， 位于CPU和主存之间， 容量小， 速度为内存的5—10倍， 由半导体材料构成。其内容是主存内存的副本拷贝， 对于程序员来说是透明的。</p><p>Cache由控制部分和存储器组成， 存储器存储数据， 控制部分判断CPU要访问的数据是否在Cache中， 在则命中， 不在则依据一定的算法从主存中替换。</p><p>地址映射： 在CPU工作时， 送出的是主存单元的地址， 而应从Cache存储器中读／写信息 。这就需要将主存地址转换为Cache存储器地址， 这种地址的转换称为地址映射， 由硬件自动完成映射， 分为下列三种方法：</p><p>直接映射： 将Cache存储器等分成块， 主存也等分成块并编号 。主存中的块与Cache 中的块的对应关系是固定的， 也即二者块号相同才能命中 。地址变换简单但不灵活， 容易造成资源浪费 。</p><figure><img src="'+h+'" alt="image-20240211133239973" tabindex="0" loading="lazy"><figcaption>image-20240211133239973</figcaption></figure><p>全相联映射： 同样都等分成块并编号。主存中任意一块都与Cache中任意一块对应。 因此可以随意调入Cache任意位置， 但地址变换复杂， 速度较慢。因为主存可以随意调入Cache任意块， 只有当Cache满了才会发生块冲突， 是最不容易发生块冲突的映像方式。</p><figure><img src="'+s+'" alt="image-20240211135549076" tabindex="0" loading="lazy"><figcaption>image-20240211135549076</figcaption></figure><p>组组相连映射： 前面两种方式的结合， 将 Cache存储器先分块再分组， 主存也同样先分块再分组， 组间采用直接映像， 即主存中组号与Cache中组号相同的组才能命中， 但是组内全相联映像， 也即组号相同的两个组内的所有块可以任意调换。</p><h2 id="三、替换算法" tabindex="-1"><a class="header-anchor" href="#三、替换算法"><span>三、替换算法</span></a></h2><p>替换算法的目标就是使Cache获得尽可能高的命中率 。常用算法有如下几种。</p><ol><li>随机替换算法。就是用随机数发生器产生一个要替换的块号， 将该块替换出去。</li><li>先进先出算法。就是将最先进入Cache的信息块替换出去。</li><li>近期最少使用算法。这种方法是将近期最少使用的Cache中 的信息块替换出去。</li><li>优化替换算法。这种方法必须先执行一次程序， 统计Cache 的替换情况 。有了这样的先验信息， 在第二次执行该程序时便可以用最有效的方式来替换。</li></ol><h2 id="四、命中率及平均时间" tabindex="-1"><a class="header-anchor" href="#四、命中率及平均时间"><span>四、命中率及平均时间</span></a></h2><p>Cache有一个命中率的概念， 即当CPU所访问的数据在Cache中时 ， 命中， 直接从Cache中读取数据， 设读取一次Cache时间为1ns， 若CPU访问的数据不在Cache中， 则需要从内存中读取， 设读取一次内存的时间为1000ns， 若在CPU多次读取数据过程中， 有90％命中 Cache， 则CPU读取一次的平均时间为<code>（ 90％＊ 1＋10％＊ 1000） ns</code></p><figure><img src="'+p+'" alt="image-20240211135930913" tabindex="0" loading="lazy"><figcaption>image-20240211135930913</figcaption></figure><div class="hint-container tip"><p class="hint-container-title">提示</p><p>随着cache容量越大，命中率相应越高</p></div><h2 id="五、磁盘结构" tabindex="-1"><a class="header-anchor" href="#五、磁盘结构"><span>五、磁盘结构</span></a></h2><p>磁盘有正反两个盘面， 每个盘面有多个同心圆， 每个同心圆是一个磁道， 每个同心圆又被划分为多个扇区， 数据就被存放在一个个扇区中。</p><p>磁头首先要寻找到对应的磁道， 然后等待磁盘进行周期旋转， 旋转到指定的扇区 ， 才能读取到对应的数据， 因此， 会产生寻道时间和等待时间。公式为： 存取时间 = 寻道时间＋等待时间（平均定位时间 ＋转动延迟）</p><div class="hint-container warning"><p class="hint-container-title">注意</p><p>寻道时间是指磁头移动到磁道所需的时间；</p><p>等待时间为等待读写的扇区转到磁头下方所用的时间。</p></div><figure><img src="'+n+'" alt="image-20240211133908453" tabindex="0" loading="lazy"><figcaption>image-20240211133908453</figcaption></figure><h2 id="六、磁盘调度算法" tabindex="-1"><a class="header-anchor" href="#六、磁盘调度算法"><span>六、磁盘调度算法</span></a></h2><p>之前已经说过，磁盘数据的读取时间分为寻道时间＋旋转时间， 也即先找到对应的磁道， 而后再旋转到对应的扇区才能读取数据， 其中寻道时间耗时最长， 需要重点调度， 有如下调度算法：</p><ol><li>先来先服务FCFS：根据进程请求访问磁盘的先后顺序进行调度。</li><li>最短寻道时间优先SSTF： 请求访问的磁道与当前磁道最近的进程优先调度，使得每次的寻道时间最短。会产生“饥饿”现象， 即远处进程可能永远无法访问。</li><li>扫描算法SCAN：又称“ 电梯算法”，磁头在磁盘上双向移动，其会选择离磁头当前所在磁道最近的请求访问的磁道， 并且与磁头移动方向一致，磁头永远都是从里向外或者从外向里一直移动完才掉头， 与电梯类似。</li><li>单向扫描调度算法CSCAN： 与SCAN不同的是，其只做单向移动， 即只能从里向外或者从外向里。</li></ol><h2 id="练习" tabindex="-1"><a class="header-anchor" href="#练习"><span>练习</span></a></h2><p>1、按照Cache地址映像的块冲突概率， 从高到低排列的是（） 。</p><p>A：全相联映像→直接映像→组相联映像</p><p>B：直接映像→组相联映像→全相联映像</p><p>C：组相联映像→全相联映像→直接映像</p><p>D：直接映像→全相联映像→组相联映像</p><details class="hint-container details"><summary>答案</summary><p>B</p></details><p>2、以下关于Cache与主存间地址映射的叙述中， 正确的是（） 。</p><p>A：操作系统负责管理Cache与主存之间的地址映射</p><p>B：程序员需要通过编程来处理Cache与主存之间的地址映射</p><p>C：应用软件对Cache与主存之间的地址映射进行调度</p><p>D：由硬件自动完成Cache与主存之间的地址映射</p><details class="hint-container details"><summary>答案</summary><p>D</p></details><p>3、假设某磁盘的每个磁道划分成11个物理块， 每块存放1个逻辑记录。逻辑记录RO， R1，R9，R10存放在同一个磁道上， 记录的存放顺序如下表所示：</p><table><thead><tr><th>物理块</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th></tr></thead><tbody><tr><td>逻辑记录</td><td>R0</td><td>R1</td><td>R2</td><td>R3</td><td>R4</td><td>R5</td><td>R6</td><td>R7</td><td>R8</td><td>R9</td><td>R10</td></tr></tbody></table><p>如果磁盘的旋转周期为33ms，磁头当前处在RO的开始处。若系统使用单缓冲区顺序处理这些记录， 每个记录处理时间为3ms， 则处理这11个记录的最长时间为() ; 若对信息存储进行优化分布后， 处理11个记录的最少时间为()</p><p>A:33ms A.33ms</p><p>B:336ms B.66ms</p><p>C:366ms C.86ms</p><p>D:376ms D.93ms</p><details class="hint-container details"><summary>答案</summary><p>CB</p><p>1、磁盘的旋转周期为33ms，也就是说每一部分旋转需要3ms，处理记录需要3ms，则处理完R0需要6ms，但此时磁盘已经转动到了R2的位置，所以必须等磁盘在此旋转至R1时，才能继续处理，依此类推</p><p>2、因处理一块数据需要6ms，所以当处理完第一块数据后，会转动到3号物理块，所以，将R1的数据移动到3号物理块处，使其可以连续处理。依此类推</p><p>第二种情况优化：</p><table><thead><tr><th>物理块</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th></tr></thead><tbody><tr><td>逻辑记录</td><td>R0</td><td>R6</td><td>R1</td><td>R7</td><td>R2</td><td>R8</td><td>R3</td><td>R9</td><td>R4</td><td>R10</td><td>R5</td></tr></tbody></table></details><p>4、在磁盘调度管理中， 应先进行移臂调度，再进行旋转调度。假设磁盘移动臂位于 21 号柱面上，进程的请求序列如下表所示。如果采用最短移臂调度算法，那么系统的响应序列应为（） 。</p><table><thead><tr><th>请求序列</th><th>柱面号</th><th>磁头号</th><th>扇区号</th></tr></thead><tbody><tr><td>1</td><td>17</td><td>8</td><td>9</td></tr><tr><td>2</td><td>23</td><td>6</td><td>3</td></tr><tr><td>3</td><td>23</td><td>9</td><td>6</td></tr><tr><td>4</td><td>32</td><td>10</td><td>5</td></tr><tr><td>5</td><td>17</td><td>8</td><td>4</td></tr><tr><td>6</td><td>32</td><td>3</td><td>10</td></tr><tr><td>7</td><td>17</td><td>7</td><td>9</td></tr><tr><td>8</td><td>23</td><td>10</td><td>4</td></tr><tr><td>9</td><td>38</td><td>10</td><td>8</td></tr></tbody></table><p>A：②⑧③④⑤①⑦⑥⑨</p><p>B：②③⑧④⑥⑨①⑤⑦</p><p>C：①②③④⑤⑥⑦⑧⑨</p><p>D：②⑧③⑤⑦①④⑥⑨</p><details class="hint-container details"><summary>答案</summary><p>D</p><p>当前在21号柱面，距离最近的柱面为23，因为存在多个23，无法判断顺序，所以看其扇区号，得出序列顺序 283，此时可排除BC</p><p>此时位于23号柱面，6号扇区，下一个最近的为17号柱面，根据扇区号得出最近的17号柱面的扇区为4，对应5号序列，所以选择D</p></details>',61),c=[r];function o(g,m){return a(),e("div",null,c)}const f=t(l,[["render",o],["__file","StorageAndCache.html.vue"]]),u=JSON.parse('{"path":"/SoftTest/Conventional/StorageAndCache.html","title":"存储系统和缓存","lang":"zh-CN","frontmatter":{"order":4,"category":"软考","feed":false,"seo":false},"headers":[{"level":2,"title":"一、分级存储体系","slug":"一、分级存储体系","link":"#一、分级存储体系","children":[]},{"level":2,"title":"二、缓存","slug":"二、缓存","link":"#二、缓存","children":[]},{"level":2,"title":"三、替换算法","slug":"三、替换算法","link":"#三、替换算法","children":[]},{"level":2,"title":"四、命中率及平均时间","slug":"四、命中率及平均时间","link":"#四、命中率及平均时间","children":[]},{"level":2,"title":"五、磁盘结构","slug":"五、磁盘结构","link":"#五、磁盘结构","children":[]},{"level":2,"title":"六、磁盘调度算法","slug":"六、磁盘调度算法","link":"#六、磁盘调度算法","children":[]},{"level":2,"title":"练习","slug":"练习","link":"#练习","children":[]}],"git":{"createdTime":1710676914000,"updatedTime":1710676914000,"contributors":[{"name":"zhanglinwei","email":"3498729975@qq.com","commits":1}]},"readingTime":{"minutes":7.8,"words":2340},"filePathRelative":"SoftTest/Conventional/StorageAndCache.md","localizedDate":"2024年3月17日"}');export{f as comp,u as data};
