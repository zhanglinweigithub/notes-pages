import{_ as e,o as a,c as i,a as s}from"./app-Vg0IViah.js";const l="/notes-pages/assets/image-20230408173150784-Cfx0b3MW.png",n="/notes-pages/assets/image-20230408173246584-8oclBw5V.png",o="/notes-pages/assets/image-20230408173507408-DkNu4_0P.png",p="/notes-pages/assets/image-20230408174259989-Bh5HMicz.png",r="/notes-pages/assets/image-20230408174411880-zqhpwAF0.png",c="/notes-pages/assets/1676427599648-4e93e95b-d127-43ca-b24d-7c0d9c7cdf01-DsORz0Ov.png",d="/notes-pages/assets/image-20230408174809046-B1iOHEAH.png",t="/notes-pages/assets/image-20230408174906987-B_YZTW7w.png",g="/notes-pages/assets/image-20230414152813389-DcQScseF.png",h="/notes-pages/assets/image-20230414153016627-C-P8slLi.png",D="/notes-pages/assets/image-20230414153149372-DF57l-5L.png",k="/notes-pages/assets/image-20230414153310070-BN3XhwBB.png",C="/notes-pages/assets/image-20230414153405262-DMHqjcKN.png",m="/notes-pages/assets/image-20230414153440368-ZC0QO_qL.png",u="/notes-pages/assets/image-20230414153552069-XEx87kU1.png",_="/notes-pages/assets/image-20230414153610699-3IFcYRwS.png",f="/notes-pages/assets/image-20230414153640986-DslPTtyU.png",v={},b=s('<h1 id="jvm垃圾回收机制" tabindex="-1"><a class="header-anchor" href="#jvm垃圾回收机制"><span>JVM垃圾回收机制</span></a></h1><p>垃圾回收，就是通过垃圾收集器把内存中没用的对象清理掉。主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收</p><p>垃圾回收涉及到的内容有：</p><ol><li>判断对象是否已死；</li><li>选择垃圾收集算法；</li><li>选择垃圾收集的时间；</li><li>选择适当的垃圾收集器清理垃圾 （已死的对象）;</li></ol><h2 id="一、判断对象是否已死" tabindex="-1"><a class="header-anchor" href="#一、判断对象是否已死"><span>一、判断对象是否已死</span></a></h2><p>判断对象是否已死有引用计数算法和可达性分析算法。</p><h3 id="_1、引用计数算法-不再使用" tabindex="-1"><a class="header-anchor" href="#_1、引用计数算法-不再使用"><span>1、引用计数算法（不再使用）</span></a></h3><p>给每一个对象添加一个引用计数器，每当有一个地方引用它时，计数器值加 1；每当有一个地方不再引用它时，计 数器值减 1；这样只要计数器的值不为 0，就说明还有地方引用它，它就不是无用的对象。</p><figure><img src="'+l+'" alt="image-20230408173150784" tabindex="0" loading="lazy"><figcaption>image-20230408173150784</figcaption></figure><p><strong>不再使用原因</strong></p><p>在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</p><figure><img src="'+n+'" alt="image-20230408173246584" tabindex="0" loading="lazy"><figcaption>image-20230408173246584</figcaption></figure><h3 id="_2、可达性分析算法" tabindex="-1"><a class="header-anchor" href="#_2、可达性分析算法"><span>2、可达性分析算法</span></a></h3><p>以 <code>GC Roots</code> 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。</p><p>了解可达性分析算法之前先了解一个概念——<code>GC Roots</code> 垃圾收集的起点</p><p>可以作为 <code>GC Roots</code> 的有</p><ul><li>虚拟机栈中本地变量表中引用的对象</li><li>方法区中静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI（Native 方 法）引用的对象</li></ul><p>当一个对象到 <code>GC Roots</code> 没有任何引用链相连（<code>GC Roots</code> 到这个对象不可达）时，就说明此对象是不可用的，是死对象</p><figure><img src="'+o+`" alt="image-20230408173507408" tabindex="0" loading="lazy"><figcaption>image-20230408173507408</figcaption></figure><p>上面被判了死刑的对象（object5、object6、object7）并不是必死无疑，还有挽救的余地。</p><p>进行可达性分析后对象和 <code>GC Roots</code> 之间没有引用链相连时，对象将会被进行一次标记，接着会判断如果对象没有覆盖 <code>Object</code>的 <code>finalize()</code> 方法或者 <code>finalize()</code> 方法已经被虚拟机调用过，那么它们就会被行刑（清除）；</p><p>如果对象覆盖了 <code>finalize()</code> 方法且还没有被调用，则会执行 <code>finalize()</code> 方法中的内容，所以在 <code>finalize()</code> 方法中如果重新与 <code>GC Roots</code> 引用链上的对象关联就可以拯救自己，但是一般不建议这么做</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>建议大家完全可以忘掉这个方法</p></div><h3 id="_3、方法区回收" tabindex="-1"><a class="header-anchor" href="#_3、方法区回收"><span>3、方法区回收</span></a></h3><p>上面说的都是对堆内存中对象的判断，方法区中主要回收的是废弃的常量和无用的类。</p><p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。</p><p>为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。</p><p>类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：</p><ul><li>该类所有的实例已经被回收（堆中不存在任何该类的实例）。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象在任何地方没有被引用（无法通过反射访问该类的方法）。</li></ul><h2 id="二、引用类型" tabindex="-1"><a class="header-anchor" href="#二、引用类型"><span>二、引用类型</span></a></h2><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。</p><p><code>Java</code> 提供了四种强度不同的引用类型。</p><h3 id="_1、强引用" tabindex="-1"><a class="header-anchor" href="#_1、强引用"><span>1、强引用</span></a></h3><p>被强引用关联的对象不会被回收。</p><p>使用 new 一个新对象的方式来创建强引用。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="shiki shiki-themes dark-plus dark-plus" style="background-color:#1E1E1E;--shiki-dark-bg:#1E1E1E;color:#D4D4D4;--shiki-dark:#D4D4D4;" tabindex="0"><code><span class="line"><span style="color:#4EC9B0;--shiki-dark:#4EC9B0;">Object</span><span style="color:#9CDCFE;--shiki-dark:#9CDCFE;"> obj</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;"> = </span><span style="color:#C586C0;--shiki-dark:#C586C0;">new</span><span style="color:#DCDCAA;--shiki-dark:#DCDCAA;"> Object</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">();</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_2、软引用" tabindex="-1"><a class="header-anchor" href="#_2、软引用"><span>2、软引用</span></a></h3><p>被软引用关联的对象只有在内存不够的情况下才会被回收。</p><p>使用 SoftReference 类来创建软引用。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="shiki shiki-themes dark-plus dark-plus" style="background-color:#1E1E1E;--shiki-dark-bg:#1E1E1E;color:#D4D4D4;--shiki-dark:#D4D4D4;" tabindex="0"><code><span class="line"><span style="color:#4EC9B0;--shiki-dark:#4EC9B0;">Object</span><span style="color:#9CDCFE;--shiki-dark:#9CDCFE;"> obj</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;"> = </span><span style="color:#C586C0;--shiki-dark:#C586C0;">new</span><span style="color:#DCDCAA;--shiki-dark:#DCDCAA;"> Object</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">();</span></span>
<span class="line"><span style="color:#4EC9B0;--shiki-dark:#4EC9B0;">SoftReference</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">&lt;</span><span style="color:#4EC9B0;--shiki-dark:#4EC9B0;">Object</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">&gt; </span><span style="color:#9CDCFE;--shiki-dark:#9CDCFE;">sf</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;"> = </span><span style="color:#C586C0;--shiki-dark:#C586C0;">new</span><span style="color:#4EC9B0;--shiki-dark:#4EC9B0;"> SoftReference</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">&lt;</span><span style="color:#4EC9B0;--shiki-dark:#4EC9B0;">Object</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">&gt;(obj);</span></span>
<span class="line"><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">obj = </span><span style="color:#569CD6;--shiki-dark:#569CD6;">null</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">;  </span><span style="color:#6A9955;--shiki-dark:#6A9955;">// 使对象只被软引用关联</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3、弱引用" tabindex="-1"><a class="header-anchor" href="#_3、弱引用"><span>3、弱引用</span></a></h3><p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</p><p>使用 WeakReference 类来创建弱引用。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="shiki shiki-themes dark-plus dark-plus" style="background-color:#1E1E1E;--shiki-dark-bg:#1E1E1E;color:#D4D4D4;--shiki-dark:#D4D4D4;" tabindex="0"><code><span class="line"><span style="color:#4EC9B0;--shiki-dark:#4EC9B0;">Object</span><span style="color:#9CDCFE;--shiki-dark:#9CDCFE;"> obj</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;"> = </span><span style="color:#C586C0;--shiki-dark:#C586C0;">new</span><span style="color:#DCDCAA;--shiki-dark:#DCDCAA;"> Object</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">();</span></span>
<span class="line"><span style="color:#4EC9B0;--shiki-dark:#4EC9B0;">WeakReference</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">&lt;</span><span style="color:#4EC9B0;--shiki-dark:#4EC9B0;">Object</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">&gt; </span><span style="color:#9CDCFE;--shiki-dark:#9CDCFE;">wf</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;"> = </span><span style="color:#C586C0;--shiki-dark:#C586C0;">new</span><span style="color:#4EC9B0;--shiki-dark:#4EC9B0;"> WeakReference</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">&lt;</span><span style="color:#4EC9B0;--shiki-dark:#4EC9B0;">Object</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">&gt;(obj);</span></span>
<span class="line"><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">obj = </span><span style="color:#569CD6;--shiki-dark:#569CD6;">null</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4、虚引用" tabindex="-1"><a class="header-anchor" href="#_4、虚引用"><span>4、虚引用</span></a></h3><p>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。</p><p>为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。</p><p>使用 PhantomReference 来创建虚引用。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="shiki shiki-themes dark-plus dark-plus" style="background-color:#1E1E1E;--shiki-dark-bg:#1E1E1E;color:#D4D4D4;--shiki-dark:#D4D4D4;" tabindex="0"><code><span class="line"><span style="color:#4EC9B0;--shiki-dark:#4EC9B0;">Object</span><span style="color:#9CDCFE;--shiki-dark:#9CDCFE;"> obj</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;"> = </span><span style="color:#C586C0;--shiki-dark:#C586C0;">new</span><span style="color:#DCDCAA;--shiki-dark:#DCDCAA;"> Object</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">();</span></span>
<span class="line"><span style="color:#4EC9B0;--shiki-dark:#4EC9B0;">PhantomReference</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">&lt;</span><span style="color:#4EC9B0;--shiki-dark:#4EC9B0;">Object</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">&gt; </span><span style="color:#9CDCFE;--shiki-dark:#9CDCFE;">pf</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;"> = </span><span style="color:#C586C0;--shiki-dark:#C586C0;">new</span><span style="color:#4EC9B0;--shiki-dark:#4EC9B0;"> PhantomReference</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">&lt;</span><span style="color:#4EC9B0;--shiki-dark:#4EC9B0;">Object</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">&gt;(obj, </span><span style="color:#569CD6;--shiki-dark:#569CD6;">null</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">);</span></span>
<span class="line"><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">obj = </span><span style="color:#569CD6;--shiki-dark:#569CD6;">null</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="三、常用垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#三、常用垃圾回收算法"><span>三、常用垃圾回收算法</span></a></h2><p>常用的垃圾回收算法有三种</p><ul><li>标记-清除算法</li><li>复制算法</li><li>标记-整理算法</li></ul><h3 id="_1、标记-清除算法" tabindex="-1"><a class="header-anchor" href="#_1、标记-清除算法"><span>1、标记-清除算法</span></a></h3><p>分为标记和清除两个阶段</p><p>首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象</p><p>缺点：</p><ol><li>标记和清除两个过程效率都不高；</li><li>标记清除之后会产生大量不连续的内存碎片</li></ol><figure><img src="`+p+'" alt="image-20230408174259989" tabindex="0" loading="lazy"><figcaption>image-20230408174259989</figcaption></figure><h3 id="_2、复制算法" tabindex="-1"><a class="header-anchor" href="#_2、复制算法"><span>2、复制算法</span></a></h3><p>把内存分为大小相等的两块，每次存储只用其中一块，当这一块用完了，就把存活的对象全部复制到另一块上</p><p>同时把使用过的这块内存空间全部清理掉，往复循环</p><p>缺点：</p><p>实际可使用的内存空间缩小为原来的一半。</p><figure><img src="'+r+'" alt="image-20230408174411880" tabindex="0" loading="lazy"><figcaption>image-20230408174411880</figcaption></figure><h4 id="复制算法优化" tabindex="-1"><a class="header-anchor" href="#复制算法优化"><span>复制算法优化</span></a></h4><p>实际上真正的复制算法会做出如下优化，把内存区域划分为三块</p><p>1个Eden区，2个Survivor区</p><p>其中Eden区占80%内存空间，每一块Survivor区各占10%内存空间</p><p>比如说Eden区有800MB内存，每 一块Survivor区就100MB内存</p><figure><img src="'+c+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>平时可以使用的，就是Eden区和其中一块Survivor区，那么相当于就是有900MB的内存是可以使用的</p><ul><li>刚开始对象都是分配在Eden区内的，如果Eden区快满了，此时就会触发垃圾回收</li><li>此时就会把Eden区中的存活对象都一次性转移到一块空着的Survivor区。</li><li>接着Eden区就会被清空，然后再次分配新对象到Eden区里，</li><li>然后就会如上图所示，Eden区和一块Survivor区里是有对象的，其中Survivor区里放的是上一次Minor GC后存活的对象。</li><li>如果下次再次Eden区满，那么再次触发Minor GC，就会把Eden区和放着上一次Minor GC后存活对象的Survivor区内的存活对象，转移到另外一块Survivor区去</li><li><strong>始终保持一块Survivor区是空着的</strong>，就这样一直<strong>循环使用这三 块内存区域。</strong></li></ul><h3 id="_3、标记-整理算法" tabindex="-1"><a class="header-anchor" href="#_3、标记-整理算法"><span>3、标记-整理算法</span></a></h3><p>先对可用的对象进行标记，然后所有被标记的对象向一段移动，最后清除可用对象边界以外的内存</p><figure><img src="'+d+'" alt="image-20230408174809046" tabindex="0" loading="lazy"><figcaption>image-20230408174809046</figcaption></figure><p>优点:</p><ul><li>不会产生内存碎片</li></ul><p>不足:</p><ul><li>需要移动大量对象，处理效率比较低</li></ul><h3 id="_4、分代收集算法" tabindex="-1"><a class="header-anchor" href="#_4、分代收集算法"><span>4、分代收集算法</span></a></h3><p>把堆内存分为新生代和老年代</p><ul><li>新生代使用：复制算法</li><li>老年代使用：标记 - 清除 或者 标记 - 整理 算法</li></ul><p>一 般新生代中的对象基本上都是朝生夕灭的，每次只有少量对象存活，因此采用复制算法，只需要复制那些少量存活的对象就可以完成垃圾收集；</p><p>老年代中的对象存活率较高，就采用标记-清除和标记-整理算法来进行回收。</p><figure><img src="'+t+'" alt="image-20230408174906987" tabindex="0" loading="lazy"><figcaption>image-20230408174906987</figcaption></figure><h2 id="四、垃圾收集器" tabindex="-1"><a class="header-anchor" href="#四、垃圾收集器"><span>四、垃圾收集器</span></a></h2><figure><img src="'+g+'" alt="image-20230414152813389" tabindex="0" loading="lazy"><figcaption>image-20230414152813389</figcaption></figure><p>以上是虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p><ul><li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；</li><li>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。</li><li><div class="hint-container tip"><p class="hint-container-title">提示</p></div></li></ul><p>除了 <code>CMS</code> 和 <code>G1</code> 之外，其它垃圾收集器都是以串行的方式执行。</p><p>:::</p><h3 id="_1、serial-收集器" tabindex="-1"><a class="header-anchor" href="#_1、serial-收集器"><span>1、Serial 收集器</span></a></h3><figure><img src="'+h+'" alt="image-20230414153016627" tabindex="0" loading="lazy"><figcaption>image-20230414153016627</figcaption></figure><p><code>Serial</code> 翻译为串行，也就是说它以串行的方式执行。</p><p>它是单线程的收集器，只会使用一个线程进行垃圾收集工作。</p><p>**优点：**简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</p><p>它是 Client 场景下的<strong>默认新生代收集器</strong>，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的</p><h3 id="_2、parnew-收集器" tabindex="-1"><a class="header-anchor" href="#_2、parnew-收集器"><span>2、ParNew 收集器</span></a></h3><figure><img src="'+D+'" alt="image-20230414153149372" tabindex="0" loading="lazy"><figcaption>image-20230414153149372</figcaption></figure><p>它是 <code>Serial</code> 收集器的多线程版本。</p><p>它是 <code>Server</code> 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 <code>Serial</code> 收集器，只有它能与 <code>CMS</code> 收集器配合使用。</p><h3 id="_3、parallel-scavenge-收集器" tabindex="-1"><a class="header-anchor" href="#_3、parallel-scavenge-收集器"><span>3、Parallel Scavenge 收集器</span></a></h3><p>与 <code>ParNew</code> 一样是多线程收集器。</p><p>其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。</p><p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。</p><p>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p><p>可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p><h3 id="_4、serial-old-收集器" tabindex="-1"><a class="header-anchor" href="#_4、serial-old-收集器"><span>4、Serial Old 收集器</span></a></h3><figure><img src="'+k+'" alt="image-20230414153310070" tabindex="0" loading="lazy"><figcaption>image-20230414153310070</figcaption></figure><p>是 <code>Serial</code> 收集器的老年代版本，也是给 <code>Client</code> 场景下的虚拟机使用。如果用在 <code>Server</code> 场景下，它有两大用途：</p><ul><li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 <code>Parallel Scavenge</code> 收集器搭配使用。</li><li>作为 <code>CMS</code> 收集器的后备预案，在并发收集发生 <code>Concurrent Mode Failure</code> 时使用。</li></ul><h3 id="_5、parallel-old-收集器" tabindex="-1"><a class="header-anchor" href="#_5、parallel-old-收集器"><span>5、Parallel Old 收集器</span></a></h3><figure><img src="'+C+'" alt="image-20230414153405262" tabindex="0" loading="lazy"><figcaption>image-20230414153405262</figcaption></figure><p>是 <code>Parallel Scavenge</code> 收集器的老年代版本。</p><p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 <code>Parallel Scavenge</code> 加 <code>Parallel Old</code> 收集器</p><h3 id="_6、cms-收集器" tabindex="-1"><a class="header-anchor" href="#_6、cms-收集器"><span>6、CMS 收集器</span></a></h3><figure><img src="'+m+'" alt="image-20230414153440368" tabindex="0" loading="lazy"><figcaption>image-20230414153440368</figcaption></figure><p><code>CMS</code>（Concurrent Mark Sweep），<code>Mark Sweep</code> 指的是标记 - 清除算法。</p><p>分为以下四个流程：</p><ul><li>初始标记：仅仅只是标记一下 <code>GC Roots</code> 能直接关联到的对象，速度很快，需要停顿。</li><li>并发标记：进行 <code>GC Roots Tracing</code> 的过程，它在整个回收过程中耗时最长，不需要停顿。</li><li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li><li>并发清除：不需要停顿。</li></ul><p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p><p>具有以下缺点：</p><ul><li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li><li>无法处理浮动垃圾，可能出现 <code>Concurrent Mode Failure</code>。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 <code>Concurrent Mode Failure</code>，这时虚拟机将临时启用 <code>Serial Old</code> 来替代 CMS。</li><li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 <code>Full GC</code>。</li></ul><h3 id="_7、g1-收集器" tabindex="-1"><a class="header-anchor" href="#_7、g1-收集器"><span>7、G1 收集器</span></a></h3><p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。它的使命是未来可以替换掉 CMS 收集器。</p><p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</p><figure><img src="'+u+'" alt="image-20230414153552069" tabindex="0" loading="lazy"><figcaption>image-20230414153552069</figcaption></figure><p>G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。</p><figure><img src="'+_+'" alt="image-20230414153610699" tabindex="0" loading="lazy"><figcaption>image-20230414153610699</figcaption></figure><p>通过引入 <code>Region</code> 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 <code>Region</code> 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 <code>Region</code>。</p><p>每个 <code>Region</code> 都有一个 <code>Remembered Set</code>，用来记录该 <code>Region</code> 对象的引用对象所在的 <code>Region</code>。通过使用 <code>Remembered Set</code>，在做可达性分析的时候就可以避免全堆扫描。</p><figure><img src="'+f+'" alt="image-20230414153640986" tabindex="0" loading="lazy"><figcaption>image-20230414153640986</figcaption></figure><p>如果不计算维护 <code>Remembered Set</code> 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 <code>Remembered Set Logs</code> 里面，最终标记阶段需要把 <code>Remembered Set Logs</code> 的数据合并到 <code>Remembered Set</code> 中。这阶段需要停顿线程，但是可并行执行。</li><li>筛选回收：首先对各个 <code>Region</code> 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 <code>Region</code>，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li></ul><p>具备如下特点：</p><ul><li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li><li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li></ul>',136),y=[b];function E(x,S){return a(),i("div",null,y)}const B=e(v,[["render",E],["__file","Recycle.html.vue"]]),R=JSON.parse('{"path":"/Doc/Java/JVM/Recycle.html","title":"JVM垃圾回收机制","lang":"zh-CN","frontmatter":{"category":"八股文"},"headers":[{"level":2,"title":"一、判断对象是否已死","slug":"一、判断对象是否已死","link":"#一、判断对象是否已死","children":[{"level":3,"title":"1、引用计数算法（不再使用）","slug":"_1、引用计数算法-不再使用","link":"#_1、引用计数算法-不再使用","children":[]},{"level":3,"title":"2、可达性分析算法","slug":"_2、可达性分析算法","link":"#_2、可达性分析算法","children":[]},{"level":3,"title":"3、方法区回收","slug":"_3、方法区回收","link":"#_3、方法区回收","children":[]}]},{"level":2,"title":"二、引用类型","slug":"二、引用类型","link":"#二、引用类型","children":[{"level":3,"title":"1、强引用","slug":"_1、强引用","link":"#_1、强引用","children":[]},{"level":3,"title":"2、软引用","slug":"_2、软引用","link":"#_2、软引用","children":[]},{"level":3,"title":"3、弱引用","slug":"_3、弱引用","link":"#_3、弱引用","children":[]},{"level":3,"title":"4、虚引用","slug":"_4、虚引用","link":"#_4、虚引用","children":[]}]},{"level":2,"title":"三、常用垃圾回收算法","slug":"三、常用垃圾回收算法","link":"#三、常用垃圾回收算法","children":[{"level":3,"title":"1、标记-清除算法","slug":"_1、标记-清除算法","link":"#_1、标记-清除算法","children":[]},{"level":3,"title":"2、复制算法","slug":"_2、复制算法","link":"#_2、复制算法","children":[]},{"level":3,"title":"3、标记-整理算法","slug":"_3、标记-整理算法","link":"#_3、标记-整理算法","children":[]},{"level":3,"title":"4、分代收集算法","slug":"_4、分代收集算法","link":"#_4、分代收集算法","children":[]}]},{"level":2,"title":"四、垃圾收集器","slug":"四、垃圾收集器","link":"#四、垃圾收集器","children":[{"level":3,"title":"1、Serial 收集器","slug":"_1、serial-收集器","link":"#_1、serial-收集器","children":[]},{"level":3,"title":"2、ParNew 收集器","slug":"_2、parnew-收集器","link":"#_2、parnew-收集器","children":[]},{"level":3,"title":"3、Parallel Scavenge 收集器","slug":"_3、parallel-scavenge-收集器","link":"#_3、parallel-scavenge-收集器","children":[]},{"level":3,"title":"4、Serial Old 收集器","slug":"_4、serial-old-收集器","link":"#_4、serial-old-收集器","children":[]},{"level":3,"title":"5、Parallel Old 收集器","slug":"_5、parallel-old-收集器","link":"#_5、parallel-old-收集器","children":[]},{"level":3,"title":"6、CMS 收集器","slug":"_6、cms-收集器","link":"#_6、cms-收集器","children":[]},{"level":3,"title":"7、G1 收集器","slug":"_7、g1-收集器","link":"#_7、g1-收集器","children":[]}]}],"git":{"createdTime":1708330205000,"updatedTime":1708873062000,"contributors":[{"name":"zhanglinwei","email":"3498729975@qq.com","commits":2}]},"readingTime":{"minutes":13.74,"words":4121},"filePathRelative":"Doc/Java/JVM/Recycle.md","localizedDate":"2024年2月19日"}');export{B as comp,R as data};
