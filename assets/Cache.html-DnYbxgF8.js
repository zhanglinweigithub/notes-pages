import{_ as l,r as a,o as d,c as s,e as t,f as n,g as i,a as r}from"./app-Vg0IViah.js";const o={},c=t("h1",{id:"配置缓存",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#配置缓存"},[t("span",null,"配置缓存")])],-1),_={href:"https://nginx.org/en/docs/",target:"_blank",rel:"noopener noreferrer"},y=r('<table><thead><tr><th style="text-align:left;">指令名称</th><th style="text-align:left;">作用</th><th style="text-align:left;">语法</th><th style="text-align:left;">默认配置</th><th style="text-align:left;">示例</th><th style="text-align:left;">作用域</th></tr></thead><tbody><tr><td style="text-align:left;">proxy_cache</td><td style="text-align:left;">设置是否开启对后端响应的缓存。</td><td style="text-align:left;">proxy_cache zone | off;</td><td style="text-align:left;">proxy_cache off;</td><td style="text-align:left;">proxy_cache mycache; # 规定开启nginx缓存并且缓存名称为: mycache</td><td style="text-align:left;">http, server, location</td></tr><tr><td style="text-align:left;">proxy_cache_valid</td><td style="text-align:left;">配置什么状态码可以被缓存，以及缓存时长</td><td style="text-align:left;">proxy_cache_valid [code ...] time;</td><td style="text-align:left;">没有默认值</td><td style="text-align:left;">proxy_cache_valid 200 304 2m; # 对于状态为200和304的缓存文件，缓存时间是2分钟</td><td style="text-align:left;">http, server, location</td></tr><tr><td style="text-align:left;">proxy_cache_key</td><td style="text-align:left;">设置缓存文件的 key</td><td style="text-align:left;">proxy_cache_key string;</td><td style="text-align:left;">proxy_cache_key proxy_host$request_uri;</td><td style="text-align:left;">proxy_cache_key &quot;request_uri $cookie_user&quot;; # 使用host +请求的uri以及cookie拼接成缓存key</td><td style="text-align:left;">http, server, location</td></tr><tr><td style="text-align:left;">proxy_cache_path</td><td style="text-align:left;">指定缓存存储的路径，文件名为cache key的md5值，然后多级目录的话，根据level参数来生成，key_zone参数用来指定在共享内存中缓存数据的名称和内存大小，比如keys_zone=mycache:100m，inactive用来指定缓存没有被访问后超时移除的时间，默认是10分钟，也可以自己指定比如inactive=2h ；max_size 用来指定缓存的最大值，超过这个值则会自动移除最近最少使用（lru淘汰算法）的缓存 这个指令对应的参数很多，具体见官网：proxy_cache_path</td><td style="text-align:left;">proxy_cache_path path [levels=levels] [use_temp_path=on|off] keys_zone=name:size [inactive=time] [max_size=size] [min_free=size] [manager_files=number] [manager_sleep=time] [manager_threshold=time] [loader_files=number] [loader_sleep=time] [loader_threshold=time] [purger=on|off] [purger_files=number] [purger_sleep=time] [purger_threshold=time];</td><td style="text-align:left;">无</td><td style="text-align:left;">proxy_cache_path /data/nginx/cache levels=1:2 keys_zone=mycache:128m inactive=3d max_size=2g; # 设置缓存存放的目录为/data/nginx/cache，并设置缓存名称为mycache，大小为128m， 三天未被访问过的缓存将自动清除，磁盘中缓存的最大容量为2GB。</td><td style="text-align:left;">http</td></tr><tr><td style="text-align:left;">proxy_cache_bypass</td><td style="text-align:left;">定义不从缓存中获取响应数据的条件。如果字符串参数中至少有一个值不为空且不等于&quot; 0 &quot;，则不会从缓存中获取响应:</td><td style="text-align:left;">proxy_cache_bypass string ...;</td><td style="text-align:left;">没有默认值</td><td style="text-align:left;">proxy_cache_bypass arg_nocache$arg_comment;</td><td style="text-align:left;">http, server, location</td></tr><tr><td style="text-align:left;">proxy_cache_min_uses</td><td style="text-align:left;">指定某一个相同请求在几次请求之后才缓存响应内容</td><td style="text-align:left;">proxy_cache_min_uses number;</td><td style="text-align:left;">proxy_cache_min_uses 1;</td><td style="text-align:left;">proxy_cache_min_uses 3; 规定某一个请求在第3次之后才走nginx缓存</td><td style="text-align:left;">http, server, location</td></tr><tr><td style="text-align:left;">proxy_cache_use_stale</td><td style="text-align:left;">指定后端服务器在返回什么状态码的情况下可以使用过期的缓存</td><td style="text-align:left;">proxy_cache_use_stale error timeout invalid_header http_500 http_502 http_503 ... |off ;</td><td style="text-align:left;">proxy_cache_use_stale off;</td><td style="text-align:left;">proxy_cache_use_stale error timeout http_500 http_502 http_503 http_504; # 规定服务在出现error timeout,以及502,503,504时可使用过期缓存</td><td style="text-align:left;">http, server, location</td></tr><tr><td style="text-align:left;">proxy_cache_lock</td><td style="text-align:left;">默认不开启，开启后若出现并发重复请求，nginx只让一个请求去后端读数据，其他的排队并尝试从缓存中读取;</td><td style="text-align:left;">proxy_cache_lock on |off;</td><td style="text-align:left;">proxy_cache_lock off;</td><td style="text-align:left;">proxy_cache_lock on; # 开启缓存锁</td><td style="text-align:left;">http, server, location</td></tr><tr><td style="text-align:left;">proxy_cache_lock_timeout</td><td style="text-align:left;">等待缓存锁(proxy_cache_lock)超时之后将直接请求后端，且结果不会被缓存</td><td style="text-align:left;">proxy_cache_lock_timeout time;</td><td style="text-align:left;">proxy_cache_lock_timeout 5s;</td><td style="text-align:left;">proxy_cache_lock_timeout 6s; # 等待缓存锁超时（6ms）之后将直接请求后端，结果不会被缓存。</td><td style="text-align:left;">http, server, location</td></tr><tr><td style="text-align:left;">proxy_cache_methods</td><td style="text-align:left;">如果客户端请求方法在该指令中，则响应将被缓存。“GET”和“HEAD”方法总是被添加到列表中，尽管建议显式地指定它</td><td style="text-align:left;">proxy_cache_methods GET|HEAD |POST ...;</td><td style="text-align:left;">proxy_cache_methods GET HEAD;</td><td style="text-align:left;">proxy_cache_methods GET HEAD PUT POST; # 规定 可缓存的方法有 ：get head put post</td><td style="text-align:left;">http, server, location</td></tr><tr><td style="text-align:left;">..............</td><td style="text-align:left;">..........</td><td style="text-align:left;">..........</td><td style="text-align:left;">..........</td><td style="text-align:left;">..........</td><td style="text-align:left;">..........</td></tr></tbody></table>',1);function x(h,f){const e=a("ExternalLinkIcon");return d(),s("div",null,[c,t("p",null,[t("a",_,[n("官方文档"),i(e)])]),y])}const p=l(o,[["render",x],["__file","Cache.html.vue"]]),m=JSON.parse('{"path":"/Use/Java/Nginx/Cache.html","title":"配置缓存","lang":"zh-CN","frontmatter":{"category":"使用篇"},"headers":[],"git":{"createdTime":1708330205000,"updatedTime":1708873062000,"contributors":[{"name":"zhanglinwei","email":"3498729975@qq.com","commits":2}]},"readingTime":{"minutes":2.69,"words":807},"filePathRelative":"Use/Java/Nginx/Cache.md","localizedDate":"2024年2月19日"}');export{p as comp,m as data};
