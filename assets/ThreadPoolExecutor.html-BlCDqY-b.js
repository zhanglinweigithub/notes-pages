import{_ as l,r as i,o,c as n,e,f as s,g as c,a as r}from"./app-Vg0IViah.js";const d="/notes-pages/assets/image-20230413132533568-C5h4je-V.png",t="/notes-pages/assets/image-20230413124649357-Bdv8OunQ.png",p="/notes-pages/assets/image-20230413124939902-CR-PNCXk.png",D={},k=e("h1",{id:"线程池",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#线程池"},[e("span",null,"线程池")])],-1),u={href:"https://www.throwx.cn/2020/08/23/java-concurrency-thread-pool-executor/",target:"_blank",rel:"noopener noreferrer"},h=r('<figure><img src="'+d+'" alt="image-20230413132533568" tabindex="0" loading="lazy"><figcaption>image-20230413132533568</figcaption></figure><ul><li>临时线程的创建时机：当所有核心线程都在忙，且任务队列满了，这时在有新的任务来才会创建临时线程去处理。</li><li>临时线程的销毁：当临时线程空闲时，经过设定的<code>keepAliveTime</code>时间后，才会销毁，而不是立即销毁。</li><li>入队时机：新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列</li></ul><h2 id="一、前置概念" tabindex="-1"><a class="header-anchor" href="#一、前置概念"><span>一、前置概念</span></a></h2><ol><li><p>执行任务需要实现 <code>Runnable</code> 接口或 <code>Callable</code>接口</p></li><li><p>任务执行机制的核心接口 <code>Executor</code> ，以及继承自 <code>Executor</code> 接口的 <code>ExecutorService</code> 接口。</p><p><code>ThreadPoolExecutor</code> 和 <code>ScheduledThreadPoolExecutor</code> 这两个关键类实现了 <code>ExecutorService</code> 接口</p></li></ol><figure><img src="'+t+'" alt="image-20230413124649357" tabindex="0" loading="lazy"><figcaption>image-20230413124649357</figcaption></figure><ol start="3"><li><p>异步计算结果的核心 <code>Future</code> 接口，以及<code>Future</code>接口的实现类<code>FutureTak</code>类</p><p>当我们把 <code>Runnable</code>接口 或 <code>Callable</code> 接口 的实现类提交给 <code>ThreadPoolExecutor</code> 或 <code>ScheduledThreadPoolExecutor</code> 执行。（调用 <code>submit()</code> 方法时会返回一个 <code>FutureTask</code> 对象）</p></li></ol><figure><img src="'+p+`" alt="image-20230413124939902" tabindex="0" loading="lazy"><figcaption>image-20230413124939902</figcaption></figure><ul><li>主线程首先要创建实现 <code>Runnable</code> 或者 <code>Callable</code> 接口的任务对象。</li><li>把创建完成的实现 <code>Runnable</code>/<code>Callable</code>接口的 对象直接交给 <code>ExecutorService</code> 执行: <ul><li><code>ExecutorService.execute（Runnable command）</code></li><li><code>ExecutorService.submit（Runnable task）</code></li><li><code>ExecutorService.submit（Callable task）</code></li></ul></li><li>如果执行 <code>ExecutorService.submit（）</code>，<code>ExecutorService</code> 将返回一个实现<code>Future</code>接口的对象 <ul><li>执行 <code>execute()</code>方法和 <code>submit()</code>方法的区别，<code>submit()</code>会返回一个 <code>FutureTask</code> 对象</li><li>由于 <code>FutureTask</code> 实现了 <code>Runnable</code>，我们也可以创建 <code>FutureTask</code>，然后直接交给 <code>ExecutorService</code> 执行。</li></ul></li><li>最后，主线程可以执行 <code>FutureTask.get()</code>方法来等待任务执行完成。 <ul><li>主线程也可以执行 <code>FutureTask.cancel（boolean mayInterruptIfRunning）</code>来取消此任务的执行。</li></ul></li></ul><h2 id="二、线程池参数" tabindex="-1"><a class="header-anchor" href="#二、线程池参数"><span>二、线程池参数</span></a></h2><div class="hint-container tip"><p class="hint-container-title">提示</p><p><code>corePoolSize</code>，<code>maximumPoolSize</code> ，<code>workQueue</code>，比较重要</p></div><p>共可接收7个参数</p><ul><li><code>corePoolSize</code>：线程池的核心线程数量</li><li><code>maximumPoolSize</code>：线程池的最大线程数</li><li><code>keepAliveTime</code>：当线程数大于核心线程数时，多余的空闲线程存活的最长时间</li><li><code>unit</code>：时间单位</li><li><code>workQueue</code>：任务队列，用来储存等待执行任务的队列</li><li><code>threadFactory</code>：线程工厂，用来创建线程</li><li><code>handler</code>：拒绝策略，当提交的任务过多而不能及时处理时，拒绝策略是怎样的</li></ul><h2 id="三、拒绝策略" tabindex="-1"><a class="header-anchor" href="#三、拒绝策略"><span>三、拒绝策略</span></a></h2><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，这时再来新任务所采取的策略</p><ul><li><code>AbortPolicy</code> ：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。（默认）</li><li><code>DiscardPolicy</code> ：不处理新任务，直接丢弃掉。</li><li><code>DiscardOldestPolicy</code> ： 此策略将丢弃最早的未处理的任务请求</li><li><code>CallerRunsPolicy</code> ：调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li></ul><p><strong>枚举：</strong></p><ul><li><code>ThreadPoolExecutor.AbortPolicy</code></li><li><code>ThreadPoolExecutor.DiscardPolicy</code></li><li><code>ThreadPoolExecutor.DiscardOldestPolicy</code></li><li><code>ThreadPoolExecutor.CallerRunsPolicy</code></li></ul><h2 id="四、阻塞队列" tabindex="-1"><a class="header-anchor" href="#四、阻塞队列"><span>四、阻塞队列</span></a></h2><ul><li><code>ArrayBlockingQueue</code>：（有界队列）是一个用数组实现的有界阻塞队列，按<code>FIFO</code>排序量</li><li><code>LinkedBlockingQueue</code>：（阻塞队列），按<code>FIFO</code>排序任务，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为<code>Integer.MAX_VALUE</code>，吞吐量通常要高于<code>ArrayBlockingQuene</code></li><li><code>DelayedWorkQueue</code>：（延迟队列）内部采用的是“堆”的数据结构，按照延迟的时间长短对任务进行排序，每次出队的任务都是当前队列中执行时间最靠前的，素满了之后会自动扩容原来容量的 <code>1/2</code>，即永远不会阻塞，最大扩容可达 <code>Integer.MAX_VALUE</code></li><li><code>PriorityBlockingQueue</code>：（优先级队列）是具有优先级的无界阻塞队列</li><li><code>SynchronousQueue</code>：（同步队列）一个不存储元素的阻塞队列，如果有空闲线程，则使用空闲线程来处理，否则新建一个线程来处理任务，线程数是可以无限扩展的，可能会创建大量线程，从而导致 <code>OOM</code></li></ul><h2 id="五、创建线程池" tabindex="-1"><a class="header-anchor" href="#五、创建线程池"><span>五、创建线程池</span></a></h2><p>使用<code>ThreadPoolExecutor</code>的构造函数来创建线程池，这样的创建方式让我们更加明确线程池的运行规则，规避资源耗尽的风险</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="shiki shiki-themes dark-plus dark-plus" style="background-color:#1E1E1E;--shiki-dark-bg:#1E1E1E;color:#D4D4D4;--shiki-dark:#D4D4D4;" tabindex="0"><code><span class="line"><span style="color:#569CD6;--shiki-dark:#569CD6;">private</span><span style="color:#569CD6;--shiki-dark:#569CD6;"> static</span><span style="color:#569CD6;--shiki-dark:#569CD6;"> final</span><span style="color:#4EC9B0;--shiki-dark:#4EC9B0;"> int</span><span style="color:#9CDCFE;--shiki-dark:#9CDCFE;"> CORE_POOL_SIZE</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;"> = </span><span style="color:#B5CEA8;--shiki-dark:#B5CEA8;">5</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="color:#569CD6;--shiki-dark:#569CD6;">private</span><span style="color:#569CD6;--shiki-dark:#569CD6;"> static</span><span style="color:#569CD6;--shiki-dark:#569CD6;"> final</span><span style="color:#4EC9B0;--shiki-dark:#4EC9B0;"> int</span><span style="color:#9CDCFE;--shiki-dark:#9CDCFE;"> MAX_POOL_SIZE</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;"> = </span><span style="color:#B5CEA8;--shiki-dark:#B5CEA8;">50</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="color:#569CD6;--shiki-dark:#569CD6;">private</span><span style="color:#569CD6;--shiki-dark:#569CD6;"> static</span><span style="color:#569CD6;--shiki-dark:#569CD6;"> final</span><span style="color:#4EC9B0;--shiki-dark:#4EC9B0;"> Long</span><span style="color:#9CDCFE;--shiki-dark:#9CDCFE;"> KEEP_ALIVE_TIME</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;"> = </span><span style="color:#B5CEA8;--shiki-dark:#B5CEA8;">1L</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#569CD6;--shiki-dark:#569CD6;">private</span><span style="color:#4EC9B0;--shiki-dark:#4EC9B0;"> ThreadPoolExecutor</span><span style="color:#9CDCFE;--shiki-dark:#9CDCFE;"> myThreadPool</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;"> = </span><span style="color:#C586C0;--shiki-dark:#C586C0;">new</span><span style="color:#DCDCAA;--shiki-dark:#DCDCAA;"> ThreadPoolExecutor</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">(</span></span>
<span class="line"><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">            CORE_POOL_SIZE, 		</span><span style="color:#6A9955;--shiki-dark:#6A9955;">// 核心线程数量</span></span>
<span class="line"><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">            MAX_POOL_SIZE, 			</span><span style="color:#6A9955;--shiki-dark:#6A9955;">// 线程池最大线程数量</span></span>
<span class="line"><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">            KEEP_ALIVE_TIME, 		</span><span style="color:#6A9955;--shiki-dark:#6A9955;">// 临时线程存活时间</span></span>
<span class="line"><span style="color:#9CDCFE;--shiki-dark:#9CDCFE;">            TimeUnit</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">.</span><span style="color:#9CDCFE;--shiki-dark:#9CDCFE;">SECONDS</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">, 		</span><span style="color:#6A9955;--shiki-dark:#6A9955;">// 时间单位</span></span>
<span class="line"><span style="color:#C586C0;--shiki-dark:#C586C0;">            new</span><span style="color:#DCDCAA;--shiki-dark:#DCDCAA;"> SynchronousQueue</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">(), </span><span style="color:#6A9955;--shiki-dark:#6A9955;">// 任务队列</span></span>
<span class="line"><span style="color:#C586C0;--shiki-dark:#C586C0;">            new</span><span style="color:#DCDCAA;--shiki-dark:#DCDCAA;"> CustomizableThreadFactory</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">(</span><span style="color:#CE9178;--shiki-dark:#CE9178;">&quot;my-thread-pool-&quot;</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">), 	</span><span style="color:#6A9955;--shiki-dark:#6A9955;">// 线程工厂</span></span>
<span class="line"><span style="color:#C586C0;--shiki-dark:#C586C0;">            new</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;"> ThreadPoolExecutor.</span><span style="color:#DCDCAA;--shiki-dark:#DCDCAA;">CallerRunsPolicy</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">()); 		</span><span style="color:#6A9955;--shiki-dark:#6A9955;">// 拒绝策略</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#569CD6;--shiki-dark:#569CD6;">public</span><span style="color:#4EC9B0;--shiki-dark:#4EC9B0;"> String</span><span style="color:#DCDCAA;--shiki-dark:#DCDCAA;"> threadPool</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">(){</span></span>
<span class="line"><span style="color:#6A9955;--shiki-dark:#6A9955;">    // 执行任务</span></span>
<span class="line"><span style="color:#9CDCFE;--shiki-dark:#9CDCFE;">	myThreadPool</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">.</span><span style="color:#DCDCAA;--shiki-dark:#DCDCAA;">execute</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">(()</span><span style="color:#569CD6;--shiki-dark:#569CD6;">-&gt;</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">{</span></span>
<span class="line"><span style="color:#DCDCAA;--shiki-dark:#DCDCAA;">		taskOne</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">(xxx);</span></span>
<span class="line"><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">	});</span></span>
<span class="line"><span style="color:#C586C0;--shiki-dark:#C586C0;">    return</span><span style="color:#CE9178;--shiki-dark:#CE9178;"> &quot;启动成功&quot;</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">;</span></span>
<span class="line"><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#569CD6;--shiki-dark:#569CD6;">public</span><span style="color:#4EC9B0;--shiki-dark:#4EC9B0;"> String</span><span style="color:#DCDCAA;--shiki-dark:#DCDCAA;"> taskOne</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">(</span><span style="color:#4EC9B0;--shiki-dark:#4EC9B0;">Object</span><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;"> obj){</span></span>
<span class="line"><span style="color:#6A9955;--shiki-dark:#6A9955;">	// do something</span></span>
<span class="line"><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,22);function C(y,E){const a=i("ExternalLinkIcon");return o(),n("div",null,[k,e("p",null,[s("文章推荐："),e("a",u,[s("4W 字从源码上分析 JUC 线程池 ThreadPoolExecutor 的实现原理"),c(a)])]),h])}const v=l(D,[["render",C],["__file","ThreadPoolExecutor.html.vue"]]),A=JSON.parse('{"path":"/Use/Java/Concurrent/ThreadPoolExecutor.html","title":"线程池","lang":"zh-CN","frontmatter":{"category":"使用篇"},"headers":[{"level":2,"title":"一、前置概念","slug":"一、前置概念","link":"#一、前置概念","children":[]},{"level":2,"title":"二、线程池参数","slug":"二、线程池参数","link":"#二、线程池参数","children":[]},{"level":2,"title":"三、拒绝策略","slug":"三、拒绝策略","link":"#三、拒绝策略","children":[]},{"level":2,"title":"四、阻塞队列","slug":"四、阻塞队列","link":"#四、阻塞队列","children":[]},{"level":2,"title":"五、创建线程池","slug":"五、创建线程池","link":"#五、创建线程池","children":[]}],"git":{"createdTime":1708330205000,"updatedTime":1708873062000,"contributors":[{"name":"zhanglinwei","email":"3498729975@qq.com","commits":2}]},"readingTime":{"minutes":4.12,"words":1236},"filePathRelative":"Use/Java/Concurrent/ThreadPoolExecutor.md","localizedDate":"2024年2月19日"}');export{v as comp,A as data};
