import{_ as a,o as e,c as i,a as s}from"./app-Vg0IViah.js";const n="/notes-pages/assets/image-20230408162038562-CavQ-19N.png",c="/notes-pages/assets/image-20230408163057563-CUWRFPVF.png",d="/notes-pages/assets/image-20230414155512638-CsYuhFY6.png",o={},l=s('<h1 id="jvm内存区域" tabindex="-1"><a class="header-anchor" href="#jvm内存区域"><span>JVM内存区域</span></a></h1><p><code>Java</code>虚拟机在运行时，会把内存空间分为若干个区域</p><p>Java虚拟机所管理的内存区域分为如下部分：</p><ul><li>方法区</li><li>堆内存：存放对象和数组 <ul><li>年轻代</li><li>老年代</li><li>永久代（方法区）</li></ul></li><li>虚拟机栈</li><li>本地方法栈</li><li>程序计数器</li></ul><figure><img src="'+n+'" alt="image-20230408162038562" tabindex="0" loading="lazy"><figcaption>image-20230408162038562</figcaption></figure><h2 id="一、方法区" tabindex="-1"><a class="header-anchor" href="#一、方法区"><span>一、方法区</span></a></h2><p>用于存储虚拟机加载的类信息、常量、静态变量，以及编译器编译后的代码等数据</p><p>和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 <code>OutOfMemoryError</code> 异常。</p><p>对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载</p><div class="hint-container warning"><p class="hint-container-title">注意</p><p><code>jdk1.8</code>中，方法区已经不存在，原方法区中存储的类信息、编译后的代码数据等已经移动到了元空间</p><p>元空间并没有处于堆内存上，而是直接占用的本地内存</p><p>原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。</p><figure><img src="'+c+`" alt="image-20230408163057563" tabindex="0" loading="lazy"><figcaption>image-20230408163057563</figcaption></figure><h3 id="_1、运行时常量池" tabindex="-1"><a class="header-anchor" href="#_1、运行时常量池"><span>1、运行时常量池</span></a></h3><p>运行时常量池是方法区的一部分。</p><p><code>Class</code> 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。</p><p>除了在编译期生成的常量，还允许动态生成，例如 <code>String</code> 类的 <code>intern()</code>。</p><h3 id="_2、直接内存" tabindex="-1"><a class="header-anchor" href="#_2、直接内存"><span>2、直接内存</span></a></h3><p>在 <code>JDK 1.4</code> 中新引入了 <code>NIO</code> 类，它可以使用 <code>Native</code> 函数库直接分配堆外内存，然后通过 <code>Java</code> 堆里的 <code>DirectByteBuffer</code> 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。</p><h3 id="_3、去除永久代的原因" tabindex="-1"><a class="header-anchor" href="#_3、去除永久代的原因"><span>3、去除永久代的原因</span></a></h3><p>（1）字符串存在永久代中，容易出现性能问题和内存溢出。</p><p>（2）类及方法的信息等比较难确定其大小，因此对 于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</p><p>（3）永久代会为 <code>GC</code> 带来不必要的复杂度，并且回收效率偏低</p><h2 id="二、堆内存" tabindex="-1"><a class="header-anchor" href="#二、堆内存"><span>二、堆内存</span></a></h2><p>存放我们在代码中创建的各种对象，是垃圾收集的主要区域（&quot;GC 堆&quot;）。</p><p>堆还可以分为</p><ul><li>新生代（YoungGeneration）</li><li>老年代（OldGeneration）</li></ul><p>堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 <code>OutOfMemoryError</code> 异常。</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>可以通过 <code>-Xms</code> 和 <code>-Xmx</code> 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="shiki shiki-themes dark-plus dark-plus" style="background-color:#1E1E1E;--shiki-dark-bg:#1E1E1E;color:#D4D4D4;--shiki-dark:#D4D4D4;" tabindex="0"><code><span class="line"><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">java -Xms1M -</span><span style="color:#4EC9B0;--shiki-dark:#4EC9B0;">Xmx2M</span><span style="color:#4EC9B0;--shiki-dark:#4EC9B0;"> HackTheJava</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></div></div><h2 id="三、虚拟机栈" tabindex="-1"><a class="header-anchor" href="#三、虚拟机栈"><span>三、虚拟机栈</span></a></h2><p>调用执行任何方法时，都会给方法创建栈帧然后入栈, 方法执行完毕之后就出栈</p><p>每个线程都有自己的<code>Java</code>虚拟机栈</p><p>栈帧用于存储局部变量表、操作数栈、常量池引用等信息</p><figure><img src="`+d+`" alt="image-20230414155512638" tabindex="0" loading="lazy"><figcaption>image-20230414155512638</figcaption></figure><div class="hint-container tip"><p class="hint-container-title">提示</p><p>可以通过 <code>-Xss</code> 这个虚拟机参数来指定每个线程的 <code>Java</code> 虚拟机栈内存大小</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="shiki shiki-themes dark-plus dark-plus" style="background-color:#1E1E1E;--shiki-dark-bg:#1E1E1E;color:#D4D4D4;--shiki-dark:#D4D4D4;" tabindex="0"><code><span class="line"><span style="color:#D4D4D4;--shiki-dark:#D4D4D4;">java -</span><span style="color:#4EC9B0;--shiki-dark:#4EC9B0;">Xss2M</span><span style="color:#4EC9B0;--shiki-dark:#4EC9B0;"> HackTheJava</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></div><p>该区域可能抛出以下异常：</p><ul><li>当线程请求的栈深度超过最大值，会抛出 <code>StackOverflowError</code> 异常；</li><li>栈进行动态扩展时如果无法申请到足够内存，会抛出 <code>OutOfMemoryError</code> 异常。</li></ul><h2 id="四、本地方法栈" tabindex="-1"><a class="header-anchor" href="#四、本地方法栈"><span>四、本地方法栈</span></a></h2><p>本地方法栈与虚拟机栈的区别是，虚拟机栈执行的是 <code>Java</code> 方法，本地方法栈执行的是本地方法（<code>Native Method</code>）</p><h2 id="五、程序计数器" tabindex="-1"><a class="header-anchor" href="#五、程序计数器"><span>五、程序计数器</span></a></h2><p>程序计数器就是用来记录当前执行的字节码指令的位置的，也就是记录目前执行到了哪一条字节码指令</p><p>每个线程都有一个独立的程序计数器</p><p>程序计数器是<code>Java</code>虚拟机规定的唯一不会发生内存溢出的区域</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>如果正在执行的是本地方法则为空</p></div><h2 id="六、元空间" tabindex="-1"><a class="header-anchor" href="#六、元空间"><span>六、元空间</span></a></h2><p><code>jdk1.8</code> 中，已经不存在永久代（方法区），替代它的一块空间叫做 “ 元空间 ”</p><p>和永久代类似，都是 <code>JVM</code> 规范对方法区的实现，但是元空间并不在虚拟机中，而是使用本地内存，元空间的大小仅受本地内存限制，但 可以通过 -<code>XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code> 来指定元空间的大小。</p>`,28),t=[l];function p(r,h){return e(),i("div",null,t)}const g=a(o,[["render",p],["__file","Memory.html.vue"]]),v=JSON.parse('{"path":"/Doc/Java/JVM/Memory.html","title":"JVM内存区域","lang":"zh-CN","frontmatter":{"category":"八股文"},"headers":[{"level":2,"title":"一、方法区","slug":"一、方法区","link":"#一、方法区","children":[]},{"level":2,"title":"三、虚拟机栈","slug":"三、虚拟机栈","link":"#三、虚拟机栈","children":[]},{"level":2,"title":"四、本地方法栈","slug":"四、本地方法栈","link":"#四、本地方法栈","children":[]},{"level":2,"title":"五、程序计数器","slug":"五、程序计数器","link":"#五、程序计数器","children":[]},{"level":2,"title":"六、元空间","slug":"六、元空间","link":"#六、元空间","children":[]}],"git":{"createdTime":1708330205000,"updatedTime":1708873062000,"contributors":[{"name":"zhanglinwei","email":"3498729975@qq.com","commits":2}]},"readingTime":{"minutes":3.79,"words":1137},"filePathRelative":"Doc/Java/JVM/Memory.md","localizedDate":"2024年2月19日"}');export{g as comp,v as data};
