import{_ as i}from"./image-20240214133554117-tcoy_Gv4.js";import{_ as a,o as e,c as p,a as t}from"./app-Vg0IViah.js";const s="/notes-pages/assets/image-20240214203402344-DFZq4i2n.png",n="/notes-pages/assets/image-20240214204532743-DATf5qmM.png",l="/notes-pages/assets/image-20240214134520412-DQfNg_G9.png",o="/notes-pages/assets/image-20240214134625298-BdAHhRia.png",r="/notes-pages/assets/image-20240214135500003-5YlURJ4w.png",g="/notes-pages/assets/image-20240214135122727-BDRY7fUB.png",c="/notes-pages/assets/image-20240214140349366-CfJWTUzz.png",P="/notes-pages/assets/image-20240214140418599-CpHXTvUD.png",d="/notes-pages/assets/image-20240214140710837-CUFZRL_z.png",S="/notes-pages/assets/image-20240214141519562-DvLK9rOM.png",m={},h=t('<h1 id="操作系统-1" tabindex="-1"><a class="header-anchor" href="#操作系统-1"><span>操作系统 - 1</span></a></h1><div class="hint-container warning"><p class="hint-container-title">注意</p><ul><li>PV必考</li></ul></div><figure><img src="'+i+'" alt="image-20240214133554117" tabindex="0" loading="lazy"><figcaption>image-20240214133554117</figcaption></figure><h2 id="一、操作系统概述" tabindex="-1"><a class="header-anchor" href="#一、操作系统概述"><span>一、操作系统概述</span></a></h2><p><strong>操作系统的作用：</strong> 通过资源管理提高计算机系统的效率；改善人机界面向用户提供友好的工作环境。</p><p><strong>操作系统的特征：</strong> 并发性、共享性、虚拟性、不确定性</p><p><strong>操作系统的功能：</strong> 进程管理、存储管理、文件管理、设备管理 、作业管理。</p><p><strong>操作系统的分类：</strong></p><ol><li>批处理操作系统</li><li>分时操作系统（轮流使用CPU工作片）</li><li>实时操作系统（快速响应）</li><li>网络操作系统</li><li>分布式操作系统（物理分散的 计 算机互联系统）</li><li>微机操作系统（Windows）</li><li>嵌入式操作系统。</li></ol><p><strong>计算机启动的基本流程为：</strong> BIOS自检 ==&gt; 主引导记录 ==&gt; 操作系统。</p><blockquote><p>自检未通过会发出长鸣叫提醒，如 滴<code>~~~</code>滴<code>~~~</code>滴</p><p>滴一声表示通过</p></blockquote><h2 id="二、进程管理" tabindex="-1"><a class="header-anchor" href="#二、进程管理"><span>二、进程管理</span></a></h2><h3 id="_1、进程的组成和状态" tabindex="-1"><a class="header-anchor" href="#_1、进程的组成和状态"><span>1、进程的组成和状态</span></a></h3><p><strong>进程是计算机中正在运行的程序的实例</strong> 。它是操作系统进行资源分配和管理的基本单位， 包括代码、 数据和执行状态等信息。</p><p><strong>进程的组成：</strong></p><ol><li>进程控制块PCB（唯一标志，序列号）</li><li>程序（描述进程要做什么）</li><li>数据（存放进程执行时所需数据）</li></ol><p><strong>进程的状态：</strong> 包括三态图、五态图</p><p>三态图，进程基础的状态是三态图， 这是系统自动控制时只有三种状态</p><ul><li>运行：拿到了CPU使用权</li><li>就绪：已经准备就绪，等待获得CPU使用权</li><li>等待：等待外部输入一些信息来继续往下执行去获取CPU使用权从而进入运行状态</li></ul><figure><img src="'+s+'" alt="image-20240214203402344" tabindex="0" loading="lazy"><figcaption>image-20240214203402344</figcaption></figure><p>五态图， 是多了两种状态： 静止就绪、静止阻塞， 需要人为的操作才会进入对应状态， 活跃就绪即就绪， 活跃阻塞即等待。</p><figure><img src="'+n+'" alt="image-20240214204532743" tabindex="0" loading="lazy"><figcaption>image-20240214204532743</figcaption></figure><blockquote><p>可知， 当人为干预后， 进程将被挂起， 进入静止状态， 此时， 需要人为激活， 才能恢到活跃状态， 之后的本质还是三态图</p></blockquote><h3 id="_2、前趋图" tabindex="-1"><a class="header-anchor" href="#_2、前趋图"><span>2、前趋图</span></a></h3><p>前趋图： 用来表示哪些任务可以并行执行， 哪些任务之间有顺序关系</p><figure><img src="'+l+'" alt="image-20240214134520412" tabindex="0" loading="lazy"><figcaption>image-20240214134520412</figcaption></figure><blockquote><p>可知， ABC可以并行执行， 但是必须ABC都执行完后， 才能执行D， 这就确定了两点： 任务间的并行、任务间的先后顺序</p></blockquote><h3 id="_3、进程资源图" tabindex="-1"><a class="header-anchor" href="#_3、进程资源图"><span>3、进程资源图</span></a></h3><p>进程资源图： 用来表示进程和资源之间的分配和请求关系</p><ul><li>出箭头表示分配资源，如R1分配给P1、P3各一个资源</li><li>入箭头表示请求资源，P2向R1请求资源</li></ul><figure><img src="'+o+'" alt="image-20240214134625298" tabindex="0" loading="lazy"><figcaption>image-20240214134625298</figcaption></figure><blockquote><p>P代表进程， R代表资源，R方框中有几个圆球就表 示有几个这种资源</p><p>在图中， R1指向P1， 表示R1 有一个资源已经分配给了P1， P1指向R2， 表示P1 还需要请求一个R2资源才能执行</p></blockquote><p><strong>阻塞节点：</strong> 某进程所请求的资源已经全部分配完毕， 无法获取所需资源， 该进程被阻塞了无法继续。如上图中P2。</p><p><strong>非阻塞节点：</strong> 某进程所请求的资源还有剩余， 可以分配给该进程继续运行。如上图中P1 、P3 。</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>当一个进程资源图中所有进程都是阻塞节点时， 即陷入死锁状态。</p></div><h3 id="_4、同步与互斥" tabindex="-1"><a class="header-anchor" href="#_4、同步与互斥"><span>4、同步与互斥</span></a></h3><p><strong>互斥：</strong> 某资源（即临界资源） 在同一时间内只能由一个任务单独使用， 使用时需要加锁， 使用完后解锁才能被其他任务使用； 如打印机</p><p><strong>同步：</strong> 多个任务可以并发执行， 只不过有速度上的差异， 在一定情况下停下等待， 不存在资源是否单独或共享的问题； 如自行车和汽车。</p><p><strong>临界资源：</strong> 各进程间需要以互斥方式对其进行访问的资源</p><p><strong>临界区：</strong> 指进程中对临界资源实施操作的那段程序。本质是一段程序代码。</p><p><strong>互斥信号量：</strong> 对临界资源采用互斥访问， 使用互斥信号量后其他进程无法访问， 初值为1。同一时间只能被一个任务使用</p><p><strong>同步信号量：</strong> 对共享资源的访问控制， 初值一般是共享资源的数量。</p><h3 id="_5、信号量" tabindex="-1"><a class="header-anchor" href="#_5、信号量"><span>5、信号量</span></a></h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p>先P后V，PV对等</p><p>执行前都是P，执行后都是V</p></div><p><strong>P操作：</strong> 申请资源， <code>S = S- 1</code>， 若<code>S &gt;= 0</code>， 则执行P操作的进程继续执行； 若<code>S &lt; 0</code>， 则置该进程为阻塞状态（因为无可用资源）， 并将其插入阻塞队列。</p><p><strong>V操作：</strong> 释放资源， <code>S = S+1</code>， 若<code>S &gt; 0</code>， 代表此时资源有空余， 没有阻塞的进程， 则该进程继续执行； 若<code>S &lt;= 0</code>， 代表此时线程在被阻塞， 所以需要从阻塞状态唤醒一个进程， 并将其插入就绪队列（此时因为缺少资源被P操作阻塞的进程可以继续执行）， 然后执行V操作的进程继续。</p><div class="hint-container warning"><p class="hint-container-title">注意</p><p>当一个被阻塞的程序被另一个程序唤醒时，不会立即执行，而是等当前正在执行的程序执行完后在执行</p></div><figure><img src="'+r+'" alt="image-20240214135500003" tabindex="0" loading="lazy"><figcaption>image-20240214135500003</figcaption></figure><div class="hint-container tip"><p class="hint-container-title">提示</p><p><code>S &gt;= 0</code>时：S表示资源</p><p><code>S &lt; 0</code>时：S表示阻塞的任务数量</p></div><h3 id="_6、生产者和消费者" tabindex="-1"><a class="header-anchor" href="#_6、生产者和消费者"><span>6、生产者和消费者</span></a></h3><p>经典问题： 生产者和消费者的问题</p><p>三个信号量： 互斥信号量S0（仓库独立使用权）， 同步信号量S1（仓库空闲位置）， 同步信号量S2（仓库商品个数） 。</p><p>生产者流程： 消费者流程：</p><p>生产一个商品S P(S0)</p><p>P(S0) P(S2)</p><p>P(S1) 取出一个商品</p><p>将商品放入仓库中 V(S1)</p><p>V(S2) V(S0)</p><p>V(S0)</p><ul><li>生产者首先申请S0将仓库占有（加锁），并申请一个空位资源S1，随后将生产出的商品放入仓库空位并释放掉仓库使用权（解锁）</li><li>消费者首先申请S0将仓库占有（加锁），并申请一个商品资源S2进行消费，此时因为消费掉了一个商品，所以仓库空位+1，最后释放掉仓库使用权S0</li></ul><h3 id="_7、死锁" tabindex="-1"><a class="header-anchor" href="#_7、死锁"><span>7、死锁</span></a></h3><p>当一个进程在等待永远不可能发生的事件时，就会产生 <strong>死锁</strong> ，若系统中有多个进程处于死锁状态，就会造成 <strong>系统死锁</strong> 。</p><p>死锁产生的四个必要条件：</p><ol><li>资源互斥</li><li>每个进程占有资源并等待其他资源</li><li>系统不能剥夺进程资源</li><li>进程资源图是一个环路</li></ol><p>死锁产生后， 解决措施是打破四大条件， 有下列方法：</p><ul><li>死锁预防： 采用某种策略限制并发进程对于资源的请求， 破坏死锁产生的四个条件之一， 使系统任何时刻都不满足死锁的条件。</li><li>死锁避免： 一般采用 <strong>银行家算法</strong> 来避免， 银行家算法， 就是提前计算出一条不会死锁的资源分配方法，才分配资源， 否则不分配资源，相当于借贷，考虑对方还得起才借钱，提前考虑好以后，就可以避免死锁。</li><li>死锁检测： 允许死锁产生，但系统定时运行一个检测死锁的程序，若检测到系统中发生死锁，则设法加以解除。</li><li>死锁解除： 即死锁发生后的解除方法，如强制剥夺资源，撤销进程等。</li></ul><p><strong>死锁计算问题：</strong> 系统内有n个进程，每个进程都需要R个资源，那么其发生死锁的最大资源数为<code>n *（R-1）</code> 。其不发生死锁的最小资源数为<code>n *（R-1）+1</code>。</p><h3 id="_8、线程" tabindex="-1"><a class="header-anchor" href="#_8、线程"><span>8、线程</span></a></h3><p>传统的进程有两个属性：</p><ol><li>可拥有资源的独立单位</li><li>可独立调度和分配的基本单位</li></ol><p>引入线程后， <strong>线程是独立调度的最小单位， 进程是拥有资源的最小单位</strong></p><p>线程可以共享进程的公共数据、全局变量、代码、文件等资源，但不能共享线程独有的资源，如线程的栈指针等标识数据</p><h2 id="三、练习" tabindex="-1"><a class="header-anchor" href="#三、练习"><span>三、练习</span></a></h2><p>1、在如下所示的进程资源图中， （）； 该进程资源图是 ()</p><figure><img src="'+g+'" alt="image-20240214135122727" tabindex="0" loading="lazy"><figcaption>image-20240214135122727</figcaption></figure><p>A：P1、P2、P3都是阻塞节点 A.可以化简的， 其化简顺序为P1→P2→P3</p><p>B：P1是阻塞节点、P2、P3是非阻塞节点 B.可以化简的， 其化简顺序为P3→P1→P2</p><p>C：P1、P2是阻塞节点、P3是非阻塞节点 C.可以化简的， 其化简顺序为P2→P1→P3</p><p>D：P1、P2是非阻塞节点、P3是阻塞节点 D.不可以化简的， 因为P1、P2、P3申请的资源都不能 得</p><details class="hint-container details"><summary>答案</summary><p>CB</p><p>1、略</p><p>2、死锁不可化简，非死锁的均可化简</p><p>化简的原则：谁是非阻塞节点就优先执行谁</p></details><p>2、进程P1、P2、P3、P4和P5 的前趋图如下图所示，若用PV操作控制进程P1 、P2 、P3 、P3 、P4和P5并发执行的过程， 则需要设置5个信号S1 、S2 、S3 、S4和 S5， 且信号量S1～S5的初值都等于零。下图中a和b处应分别填（26）； c和d处应分别填写（27）； e和f处应分别填写（28） 。</p><figure><img src="'+c+'" alt="image-20240214140349366" tabindex="0" loading="lazy"><figcaption>image-20240214140349366</figcaption></figure><p>（26）A：V（S1） P（S2） 和V（S3） B：P（S1） V（S2） 和V（S3）</p><p>​ C：V（S1） V（S2） 和V（S3） D：P（S1） P（S2） 和V（S3）</p><p>（27）A：P（S2） 和P（S4） B：P（S2） 和V（S4）</p><p>​ C：V（s2） 和P（s4） D： V（S2） 和V（S4）</p><p>（28）A： P（S4） 和V（S4）V（S5） B： V（S5） 和P（S4） P（S5）</p><p>​ C： V （S3 ） 和 v （s4 ） v （s5 ） D： P （S3 ） 和 P （S4 ） V （P5 ）</p><details class="hint-container details"><summary>答案</summary><p>CBB</p><p>先P后V，PV对等，带入图中</p><p>执行前都是P，执行后都是V</p></details><p>3、进程P1 、P2 、P3 、P4 、P5和P6的前趋图如下所示， 若用PV操作控制这6个进程的同步与互斥的程序如下， 那么程序中的空①和空②处应分别为 （） ； 空③和空④处应分别为 () ；空⑤和空⑥处应分别（） 。</p><figure><img src="'+P+'" alt="image-20240214140418599" tabindex="0" loading="lazy"><figcaption>image-20240214140418599</figcaption></figure><p>A.V（S1） V（S2） 和P（S2） B.P（S1） P（S2） 和V（S2）</p><p>C.V（S1）V（S2） 和P（S1） D.P（S1） P（S2） 和V（S1）</p><p>A.V（S3） 和V（S5） V（S6） B.P（S3） 和V（S5）V（S6）</p><p>C.V（S3） 和P（S5） P（S6） D.P（S3） 和P（S5） P（S6）</p><p>A.P（S6） 和P（S7） V（S8） B.V（S6） 和V（S7）V（S8）</p><p>C.P（S6） 和P（S7）P（S8） D.V（S7） 和P（S7）P（S8）</p><details class="hint-container details"><summary>答案</summary><p>CBD</p><p>先P后V，PV对等，带入图中</p><p>执行前都是P，执行后都是V</p></details><p>4、假设某系统采用非抢占式优先级调度算法， 若该系统有两个优先级相同的进程P1和P2， 各进程的程序段如下所示， 若信号量S1和S2的初值都为0 。进程P1和P2并发执行后a 、b 和c的结果分别为： a=（） ，b=（ ），c=( )。</p><figure><img src="'+d+'" alt="image-20240214140710837" tabindex="0" loading="lazy"><figcaption>image-20240214140710837</figcaption></figure><p>A. 6 B. 7 C. 10 D. 13</p><p>A. 4 B. 6 C. 9 D. 10</p><p>A. 4 B. 6 C. 10 D. 13</p><details class="hint-container details"><summary>答案</summary><p>DBC</p><p>非抢占式优先级调度算法，即顺序执行，因P1在前所以先执行P1</p><p>a=1，a=3，释放S1资源，此时S1=1继续执行，c=4，申请S2，此时S2=-1，P1程序进入阻塞，转而执行P2</p><p>b=1，b=3，申请S1，此时S1=0继续执行，b=6，申请S2，此时S2=0，唤醒P1，P2继续执行，c=10</p><p>P2执行完毕，P1执行，a=13，得出a=13，b=6，c=10</p></details><p>5、某系统中有3个并发进程竞争资源R， 每个进程都需要5个R， 那么至少有 ()</p><p>A.12 B.13 C.14 D.15</p><details class="hint-container details"><summary>答案</summary><p>B</p><p>系统内有n个进程，每个进程都需要R个资源，那么：</p><ul><li>生死锁的最大资源数为<code>n *（R-1）</code></li><li>不发生死锁的最小资源数为<code>n *（R-1）+1</code>。</li></ul></details><p>6、银行家算法真题： 假设系统中有三类互斥资源R1 、R2和R3， 可用资源数分别为10 、5和3。 在TO时刻系统中有P1 、P2 、P3 、P3和P5五个进程， 这些进程对资源的最大需求和已分配资源数如下表所示， 此时系统剩余的可用资源数分别为（27） 。如果进程按（28） 序列执行， 那么系统状态是安全的。</p><figure><img src="'+S+'" alt="image-20240214141519562" tabindex="0" loading="lazy"><figcaption>image-20240214141519562</figcaption></figure><p>（27）A. 1、1和0 B. 1、1和1 C. 2 、1和0 D. 2、0和1</p><p>（28）A. P1→P2→P4→P5→P3 B. P5→P2→P4→P3→P1</p><p>​ C. P4→P2→P1→P5→P3 D. P5→P1→P4→P2→P3</p><details class="hint-container details"><summary>答案</summary><p>DB</p><p>1、R1剩余资源=10-(1+2+3+1+1) = 2</p><p>​ R2剩余资源=5-(1+1+1+1+1) = 0</p><p>​ R3剩余资源=3-(1+0+0+1+0) = 1</p><p>2、已知R1、R2、R3资源各剩余2、0、1</p><p>若P1先执行，其还需4个R1，不够，所以排除A选项</p><p>若P4先执行，其还需2个R2，不够，所以排除C选项</p><p>若P5先执行，个资源都够，没问题，P5执行完释放资源，此时R1、R2、R3各剩余3、1、1，若执行P1，则需4个R1，不够，所以排除D选项，故选择B选项</p></details>',113),f=[h];function _(u,V){return e(),p("div",null,f)}const C=a(m,[["render",_],["__file","OperatingSystem1.html.vue"]]),B=JSON.parse('{"path":"/SoftTest/Conventional/OperatingSystem1.html","title":"操作系统 - 1","lang":"zh-CN","frontmatter":{"order":6,"category":"软考","feed":false,"seo":false},"headers":[{"level":2,"title":"一、操作系统概述","slug":"一、操作系统概述","link":"#一、操作系统概述","children":[]},{"level":2,"title":"二、进程管理","slug":"二、进程管理","link":"#二、进程管理","children":[{"level":3,"title":"1、进程的组成和状态","slug":"_1、进程的组成和状态","link":"#_1、进程的组成和状态","children":[]},{"level":3,"title":"2、前趋图","slug":"_2、前趋图","link":"#_2、前趋图","children":[]},{"level":3,"title":"3、进程资源图","slug":"_3、进程资源图","link":"#_3、进程资源图","children":[]},{"level":3,"title":"4、同步与互斥","slug":"_4、同步与互斥","link":"#_4、同步与互斥","children":[]},{"level":3,"title":"5、信号量","slug":"_5、信号量","link":"#_5、信号量","children":[]},{"level":3,"title":"6、生产者和消费者","slug":"_6、生产者和消费者","link":"#_6、生产者和消费者","children":[]},{"level":3,"title":"7、死锁","slug":"_7、死锁","link":"#_7、死锁","children":[]},{"level":3,"title":"8、线程","slug":"_8、线程","link":"#_8、线程","children":[]}]},{"level":2,"title":"三、练习","slug":"三、练习","link":"#三、练习","children":[]}],"git":{"createdTime":1710676914000,"updatedTime":1710676914000,"contributors":[{"name":"zhanglinwei","email":"3498729975@qq.com","commits":1}]},"readingTime":{"minutes":11.16,"words":3347},"filePathRelative":"SoftTest/Conventional/OperatingSystem1.md","localizedDate":"2024年3月17日"}');export{C as comp,B as data};
