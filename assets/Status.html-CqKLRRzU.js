import{_ as t,o as e,c as o,a}from"./app-Vg0IViah.js";const r="/notes-pages/assets/image-20230413123045610-D7v79Cf6.png",d={},n=a('<h1 id="线程状态" tabindex="-1"><a class="header-anchor" href="#线程状态"><span>线程状态</span></a></h1><p><strong>线程一共有六种状态</strong></p><p>一个线程只能处于一种状态，并且这里的线程状态特指 <code>Java</code> 虚拟机的线程状态，不能反映线程在特定操作系统下的状态</p><figure><img src="'+r+'" alt="image-20230413123045610" tabindex="0" loading="lazy"><figcaption>image-20230413123045610</figcaption></figure><p><strong>新建（NEW）：</strong> 创建后尚未启动</p><p><strong>可运行（RUNNABLE）：</strong> 线程已经调用了<code>start()</code>，等待<code>CPU</code>调度</p><p><strong>阻塞（BLOCKED）：</strong> 线程在执行的时候未竞争到锁对象，则该线程进入阻塞状态</p><p><strong>无限期等待（WAITING）：</strong> 等待其它线程调用<code>notify()</code>或<code>notifyAll()</code>显式地唤醒。</p><p><strong>限期等待（TIMED WAITING）：</strong> 无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p><p><strong>死亡（TERMINATED）：</strong> 可以是线程结束任务之后自己结束，或者产生了异常而结束。</p><div class="hint-container info"><p class="hint-container-title">阻塞和等待</p><p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 <code>monitor lock</code>。</p><p>而等待是主动的，通过调用 <code>Object.wait()</code> 等方法进入。</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>没有设置 Timeout 参数的 Object.wait() 方法</td><td>Object.notify() / Object.notifyAll()</td></tr><tr><td>没有设置 Timeout 参数的 Thread.join() 方法</td><td>被调用的线程执行完毕</td></tr><tr><td>LockSupport.park() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table></div><div class="hint-container info"><p class="hint-container-title">限期等待</p><p>调用 <code>Thread.sleep()</code> 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。</p><p>调用 <code>Object.wait()</code> 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>Thread.sleep() 方法</td><td>时间结束</td></tr><tr><td>设置了 Timeout 参数的 Object.wait() 方法</td><td>时间结束 / Object.notify() / Object.notifyAll()</td></tr><tr><td>设置了 Timeout 参数的 Thread.join() 方法</td><td>时间结束 / 被调用的线程执行完毕</td></tr><tr><td>LockSupport.parkNanos() 方法</td><td>LockSupport.unpark(Thread)</td></tr><tr><td>LockSupport.parkUntil() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table></div><div class="hint-container tip"><p class="hint-container-title">提示</p><p>睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</p></div>',13),i=[n];function c(s,p){return e(),o("div",null,i)}const h=t(d,[["render",c],["__file","Status.html.vue"]]),g=JSON.parse('{"path":"/Use/Java/Concurrent/Status.html","title":"线程状态","lang":"zh-CN","frontmatter":{"category":"使用篇"},"headers":[],"git":{"createdTime":1708330205000,"updatedTime":1708873062000,"contributors":[{"name":"zhanglinwei","email":"3498729975@qq.com","commits":2}]},"readingTime":{"minutes":1.56,"words":469},"filePathRelative":"Use/Java/Concurrent/Status.md","localizedDate":"2024年2月19日"}');export{h as comp,g as data};
